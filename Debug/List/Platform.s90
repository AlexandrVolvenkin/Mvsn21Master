///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR          02/Dec/2022  16:58:08
// Copyright 1996-2018 IAR Systems AB.
//
//    Source file  =  D:\Projects\CautoProjects\Mvsn21\Mvsn21\src\Platform.cpp
//    Command line =  
//        -f C:\Users\ghost\AppData\Local\Temp\EWFCBA.tmp
//        (--string_literals_in_flash
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\src\Platform.cpp --cpu=m48
//        -ms -o D:\Projects\CautoProjects\Mvsn21\Mvsn21\Debug\Obj -lB
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\Debug\List
//        --initializers_in_flash --root_variables --debug
//        -DENABLE_BIT_DEFINITIONS -e -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\include\ -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\Modbus\ --eeprom_size 256
//        --dlib --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 8.0\avr\LIB\DLIB\dlAVR-1s-ec_mul-n.h" -Ohz --eec++)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\Debug\List\Platform.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME Platform

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?EPILOGUE_B2_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B5_L09
        EXTERN ?L_SHL_L03
        EXTERN ?PROLOGUE2_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE5_L09
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?UL_DIVMOD_L03
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC ??CSpi
        PUBLIC ??ChannelSelect
        PUBLIC ??Disable
        PUBLIC ??Disable_1
        PUBLIC ??Enable
        PUBLIC ??Enable_1
        PUBLIC ??Exchange
        PUBLIC ??GetMeasureValue
        PUBLIC ??Init
        PUBLIC ??Init_1
        PUBLIC ??Init_2
        PUBLIC ??Init_3
        PUBLIC ??Int0InterruptDisable
        PUBLIC ??Int0InterruptEnable
        PUBLIC ??Read
        PUBLIC ??ReadByte
        PUBLIC ??Read_1
        PUBLIC ??ReceiveDisable
        PUBLIC ??ReceiveEnable
        PUBLIC ??Reset
        PUBLIC ??Reset_1
        PUBLIC ??SIG_INT0
        PUBWEAK `??SIG_INT0::??INTVEC 2`
        PUBLIC ??SIG_UART0_DATA
        PUBWEAK `??SIG_UART0_DATA::??INTVEC 38`
        PUBLIC ??SIG_UART0_RECV
        PUBWEAK `??SIG_UART0_RECV::??INTVEC 36`
        PUBLIC ??SIG_UART0_TXC
        PUBWEAK `??SIG_UART0_TXC::??INTVEC 40`
        PUBLIC ??SendByte
        PUBLIC ??Start
        PUBLIC ??Stop
        PUBLIC ??SystemTickInit
        PUBLIC ??SystemTickInterrupt
        PUBWEAK `??SystemTickInterrupt::??INTVEC 14`
        PUBLIC ??TransmitDisable
        PUBLIC ??TransmitEnable
        PUBLIC ??UartBind
        PUBLIC ??Write
        PUBLIC ??WriteByte
        PUBLIC ??Write_1
        PUBWEAK ??__vtbl
        PUBLIC ??m_UBRRH
        PUBLIC ??m_UBRRL
        PUBLIC ??m_UCSRA
        PUBLIC ??m_UCSRB
        PUBLIC ??m_UCSRC
        PUBLIC ??m_UDR
        PUBLIC ??m_auiIntermediateBuff
        PUBLIC ??m_auiSpiRxBuffer
        PUBLIC ??m_auiSpiTxBuffer
        PUBLIC ??m_bfByteIsReceived
        PUBLIC ??m_bfByteIsReceived_1
        PUBLIC ??m_bfByteIsTransmited
        PUBLIC ??m_bfDataExchangeInProgress
        PUBLIC ??m_bfDataExchangeIsOccur
        PUBLIC ??m_bfFrameIsSended
        PUBLIC ??m_bfRxBuffOverflow
        PUBLIC ??m_bfRxBuffOverflow_1
        PUBLIC ??m_fbMeasureIsComlete
        PUBLIC ??m_nuiBuffByteCounter
        PUBLIC ??m_nuiRxBuffByteCounter
        PUBLIC ??m_nuiTxBuffByteCounter
        PUBLIC ??m_puiRxBuffer
        PUBLIC ??m_puiRxBuffer_1
        PUBLIC ??m_puiTxBuffer
        PUBLIC ??m_puiTxBuffer_1
        PUBLIC ??m_rs485ddpin
        PUBLIC ??m_rs485ddr
        PUBLIC ??m_rs485pin
        PUBLIC ??m_rs485port
        PUBLIC ??m_uiExchangeByte
        PUBLIC ??m_uiReceivedByteCounter
        PUBLIC ??m_uiSystemTick
        PUBLIC `??new CSpi`
        PUBLIC ??uiSlaveSelectIsHigh
        PUBLIC `?~CSpi`
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADCSRB
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_CLKPR
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_DIDR0
        PUBWEAK _A_DIDR1
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_EICRA
        PUBWEAK _A_EIFR
        PUBWEAK _A_EIMSK
        PUBWEAK _A_GPIOR0
        PUBWEAK _A_GPIOR1
        PUBWEAK _A_GPIOR2
        PUBWEAK _A_GTCCR
        PUBWEAK _A_ICR1
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUSR
        PUBWEAK _A_OCR0A
        PUBWEAK _A_OCR0B
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR2A
        PUBWEAK _A_OCR2B
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PCICR
        PUBWEAK _A_PCIFR
        PUBWEAK _A_PCMSK0
        PUBWEAK _A_PCMSK1
        PUBWEAK _A_PCMSK2
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_PRR
        PUBWEAK _A_SMCR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0A
        PUBWEAK _A_TCCR0B
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR1C
        PUBWEAK _A_TCCR2A
        PUBWEAK _A_TCCR2B
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TIFR0
        PUBWEAK _A_TIFR1
        PUBWEAK _A_TIFR2
        PUBWEAK _A_TIMSK0
        PUBWEAK _A_TIMSK1
        PUBWEAK _A_TIMSK2
        PUBWEAK _A_TWAMR
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRR0
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UCSR0C
        PUBWEAK _A_UDR0
        PUBWEAK _A_WDTCSR
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

`?<Name CMvsn21 0>` SYMBOL "CMvsn21"
??m_uiFlowControl   SYMBOL "m_uiFlowControl", `?<Name CMvsn21 0>`
??m_uiMeasureFlowControl SYMBOL "m_uiMeasureFlowControl", `?<Name CMvsn21 0>`
`?<Name CSpi 7>`    SYMBOL "CSpi"
`?<Name CAdc 13>`   SYMBOL "CAdc"
`?<Name CUart 33>`  SYMBOL "CUart"
`?<Name CPlatform 39>` SYMBOL "CPlatform"

`??SIG_INT0::??INTVEC 2` SYMBOL "??INTVEC 2", ??SIG_INT0

`??SIG_UART0_DATA::??INTVEC 38` SYMBOL "??INTVEC 38", ??SIG_UART0_DATA

`??SIG_UART0_RECV::??INTVEC 36` SYMBOL "??INTVEC 36", ??SIG_UART0_RECV

`??SIG_UART0_TXC::??INTVEC 40` SYMBOL "??INTVEC 40", ??SIG_UART0_TXC

`??SystemTickInterrupt::??INTVEC 14` SYMBOL "??INTVEC 14", ??SystemTickInterrupt
??__vtbl            SYMBOL "__vtbl", `?<Name CSpi 7>`
??m_UBRRH           SYMBOL "m_UBRRH", `?<Name CUart 33>`
??m_UBRRL           SYMBOL "m_UBRRL", `?<Name CUart 33>`
??m_UCSRA           SYMBOL "m_UCSRA", `?<Name CUart 33>`
??m_UCSRB           SYMBOL "m_UCSRB", `?<Name CUart 33>`
??m_UCSRC           SYMBOL "m_UCSRC", `?<Name CUart 33>`
??m_UDR             SYMBOL "m_UDR", `?<Name CUart 33>`
??m_auiIntermediateBuff SYMBOL "m_auiIntermediateBuff", `?<Name CUart 33>`
??m_auiSpiRxBuffer  SYMBOL "m_auiSpiRxBuffer", `?<Name CSpi 7>`
??m_auiSpiTxBuffer  SYMBOL "m_auiSpiTxBuffer", `?<Name CSpi 7>`
??m_bfByteIsReceived SYMBOL "m_bfByteIsReceived", `?<Name CUart 33>`
??m_bfByteIsReceived_1 SYMBOL "m_bfByteIsReceived", `?<Name CSpi 7>`
??m_bfByteIsTransmited SYMBOL "m_bfByteIsTransmited", `?<Name CSpi 7>`
??m_bfDataExchangeInProgress SYMBOL "m_bfDataExchangeInProgress", `?<Name CSpi 7>`
??m_bfDataExchangeIsOccur SYMBOL "m_bfDataExchangeIsOccur", `?<Name CSpi 7>`
??m_bfFrameIsSended SYMBOL "m_bfFrameIsSended", `?<Name CUart 33>`
??m_bfRxBuffOverflow SYMBOL "m_bfRxBuffOverflow", `?<Name CUart 33>`
??m_bfRxBuffOverflow_1 SYMBOL "m_bfRxBuffOverflow", `?<Name CSpi 7>`
??m_fbMeasureIsComlete SYMBOL "m_fbMeasureIsComlete", `?<Name CAdc 13>`
??m_nuiBuffByteCounter SYMBOL "m_nuiBuffByteCounter", `?<Name CSpi 7>`
??m_nuiRxBuffByteCounter SYMBOL "m_nuiRxBuffByteCounter", `?<Name CUart 33>`
??m_nuiTxBuffByteCounter SYMBOL "m_nuiTxBuffByteCounter", `?<Name CUart 33>`
??m_puiRxBuffer     SYMBOL "m_puiRxBuffer", `?<Name CUart 33>`
??m_puiRxBuffer_1   SYMBOL "m_puiRxBuffer", `?<Name CSpi 7>`
??m_puiTxBuffer     SYMBOL "m_puiTxBuffer", `?<Name CUart 33>`
??m_puiTxBuffer_1   SYMBOL "m_puiTxBuffer", `?<Name CSpi 7>`
??m_rs485ddpin      SYMBOL "m_rs485ddpin", `?<Name CUart 33>`
??m_rs485ddr        SYMBOL "m_rs485ddr", `?<Name CUart 33>`
??m_rs485pin        SYMBOL "m_rs485pin", `?<Name CUart 33>`
??m_rs485port       SYMBOL "m_rs485port", `?<Name CUart 33>`
??m_uiExchangeByte  SYMBOL "m_uiExchangeByte", `?<Name CSpi 7>`
??m_uiReceivedByteCounter SYMBOL "m_uiReceivedByteCounter", `?<Name CSpi 7>`
??m_uiSystemTick    SYMBOL "m_uiSystemTick", `?<Name CPlatform 39>`
??uiSlaveSelectIsHigh SYMBOL "uiSlaveSelectIsHigh", `?<Name CPlatform 39>`

        EXTERN ??m_uiFlowControl
        EXTERN ??m_uiMeasureFlowControl
        EXTERN `??operator delete`
        EXTERN `??operator new`

// D:\Projects\CautoProjects\Mvsn21\Mvsn21\src\Platform.cpp
//    1 //-----------------------------------------------------------------------------------------------------
//    2 //  Source      : FileName.cpp
//    3 //  Created     : 01.06.2022
//    4 //  Author      : Alexandr Volvenkin
//    5 //  email       : aav-36@mail.ru
//    6 //  GitHub      : https://github.com/AlexandrVolvenkin
//    7 //-----------------------------------------------------------------------------------------------------
//    8 #include "Platform.h"

        ASEGN ABSOLUTE:DATA:ROOT,0c6H
// union <unnamed> volatile __io _A_UDR0
_A_UDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c4H
// union <unnamed> volatile __io _A_UBRR0
_A_UBRR0:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,0c2H
// union <unnamed> volatile __io _A_UCSR0C
_A_UCSR0C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c1H
// union <unnamed> volatile __io _A_UCSR0B
_A_UCSR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c0H
// union <unnamed> volatile __io _A_UCSR0A
_A_UCSR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bdH
// union <unnamed> volatile __io _A_TWAMR
_A_TWAMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bcH
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bbH
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0baH
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b9H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b8H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b6H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b4H
// union <unnamed> volatile __io _A_OCR2B
_A_OCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b3H
// union <unnamed> volatile __io _A_OCR2A
_A_OCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b2H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b1H
// union <unnamed> volatile __io _A_TCCR2B
_A_TCCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b0H
// union <unnamed> volatile __io _A_TCCR2A
_A_TCCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08aH
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,088H
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,086H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,084H
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,082H
// union <unnamed> volatile __io _A_TCCR1C
_A_TCCR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,081H
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,080H
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07fH
// union <unnamed> volatile __io _A_DIDR1
_A_DIDR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07eH
// union <unnamed> volatile __io _A_DIDR0
_A_DIDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07cH
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07bH
// union <unnamed> volatile __io _A_ADCSRB
_A_ADCSRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07aH
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,078H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,070H
// union <unnamed> volatile __io _A_TIMSK2
_A_TIMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06fH
// union <unnamed> volatile __io _A_TIMSK1
_A_TIMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06eH
// union <unnamed> volatile __io _A_TIMSK0
_A_TIMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06dH
// union <unnamed> volatile __io _A_PCMSK2
_A_PCMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06cH
// union <unnamed> volatile __io _A_PCMSK1
_A_PCMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06bH
// union <unnamed> volatile __io _A_PCMSK0
_A_PCMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,069H
// union <unnamed> volatile __io _A_EICRA
_A_EICRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,068H
// union <unnamed> volatile __io _A_PCICR
_A_PCICR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,066H
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,064H
// union <unnamed> volatile __io _A_PRR
_A_PRR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,061H
// union <unnamed> volatile __io _A_CLKPR
_A_CLKPR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,060H
// union <unnamed> volatile __io _A_WDTCSR
_A_WDTCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUSR
_A_MCUSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_SMCR
_A_SMCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04dH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04bH
// union <unnamed> volatile __io _A_GPIOR2
_A_GPIOR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_GPIOR1
_A_GPIOR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR0B
_A_OCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,047H
// union <unnamed> volatile __io _A_OCR0A
_A_OCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR0B
_A_TCCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCCR0A
_A_TCCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_GTCCR
_A_GTCCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03fH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_GPIOR0
_A_GPIOR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EIMSK
_A_EIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EIFR
_A_EIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PCIFR
_A_PCIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_TIFR2
_A_TIFR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_TIFR1
_A_TIFR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_TIFR0
_A_TIFR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,025H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS8 1
//    9 #include "Mvsn21.h"
//   10 #include "Modbus.h"
//   11 
//   12 // ATMega48
//   13 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   14 bool CAdc::m_fbMeasureIsComlete;
??m_fbMeasureIsComlete:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_UBRRH:
        DS8 2
??m_UBRRL:
        DS8 2
??m_UCSRA:
        DS8 2
??m_UCSRB:
        DS8 2
??m_UCSRC:
        DS8 2
??m_UDR:
        DS8 2
??m_puiTxBuffer:
        DS8 2
??m_nuiTxBuffByteCounter:
        DS8 2
??m_puiRxBuffer:
        DS8 2
??m_nuiRxBuffByteCounter:
        DS8 2
??m_auiIntermediateBuff:
        DS8 16
??m_bfByteIsReceived:
        DS8 1
??m_bfFrameIsSended:
        DS8 1
??m_bfRxBuffOverflow:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_rs485ddr:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_rs485ddpin:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_rs485port:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_rs485pin:
        DS8 1

        RSEG CODE:CODE:NOROOT(1)
// __version_3 CSpi &CSpi::new CSpi()
`??new CSpi`:
        LDI     R16, 2
        LDI     R17, 0
        RCALL   `??operator new`
        MOV     R18, R16
        OR      R18, R17
        BREQ    `??new CSpi_1`
        RJMP    ?Subroutine1
`??new CSpi_1`:
        LDI     R16, 0
        REQUIRE ?Subroutine17
        ;               // Fall through to label ?Subroutine17

        RSEG CODE:CODE:NOROOT(1)
?Subroutine17:
        LDI     R17, 0
        RET
//   15 ////-----------------------------------------------------------------------------------------------------
//   16 //CAdc::CAdc()
//   17 //{
//   18 //
//   19 //}
//   20 //
//   21 ////-----------------------------------------------------------------------------------------------------
//   22 //CAdc::~CAdc()
//   23 //{
//   24 //
//   25 //}
//   26 
//   27 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   28 void CAdc::Init(void)
??Init:
//   29 {
//   30     // Отключаем цифровые входные буферы на линиях АЦП.
//   31     DIDR0  = 0x3F;
        LDI     R16, 63
        STS     _A_DIDR0, R16
//   32     // SCK/128
//   33     ADCSRA = CAdc::DIV128;
        LDI     R16, 7
        STS     _A_ADCSRA, R16
//   34     ADCSRB = 0x00;
        LDI     R16, 0
        STS     _A_ADCSRB, R16
//   35     // Внутренний источник опорного напряжения Vref = 1.1V
//   36     ADMUX = (BIT(REFS1) | BIT(REFS0));
        LDI     R16, 192
        STS     _A_ADMUX, R16
//   37 }
        RET
        REQUIRE _A_DIDR0
        REQUIRE _A_ADCSRA
        REQUIRE _A_ADCSRB
        REQUIRE _A_ADMUX
//   38 
//   39 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   40 void CAdc::ChannelSelect(uint8_t uiChannel)
??ChannelSelect:
//   41 {
//   42     ADMUX &= ~(0x0F);
        LDS     R17, _A_ADMUX
        ANDI    R17, 0xF0
        STS     _A_ADMUX, R17
//   43     ADMUX |= (uiChannel & 0x0F);
        ANDI    R16, 0x0F
        LDS     R17, _A_ADMUX
        OR      R17, R16
        STS     _A_ADMUX, R17
//   44 }
        RET
        REQUIRE _A_ADMUX
//   45 
//   46 ////-----------------------------------------------------------------------------------------------------
//   47 //void CAdc::StartSingle(void)
//   48 //{
//   49 //    // Отключаем режим пониженного энергопотребления.
//   50 //    PRR &= ~BIT(PRADC);
//   51 //    // Включаем АЦП.
//   52 //    ADCSRA |= (BIT(ADEN) | BIT(ADIE) | BIT(ADSC));
//   53 //}
//   54 
//   55 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   56 void CAdc::Start(void)
??Start:
//   57 {
//   58     // Включаем АЦП.
//   59     ADCSRA |= (BIT(ADEN) | BIT(ADSC));
        LDS     R16, _A_ADCSRA
        ORI     R16, 0xC0
        REQUIRE ?Subroutine15
        REQUIRE _A_ADCSRA
        ;               // Fall through to label ?Subroutine15
//   60 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine15:
        STS     _A_ADCSRA, R16
        RET
//   61 
//   62 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   63 void CAdc::Stop(void)
??Stop:
//   64 {
//   65     // Выключаем АЦП.
//   66     ADCSRA &= ~(BIT(ADEN) | BIT(ADSC));
        REQUIRE ?Subroutine2
        REQUIRE _A_ADCSRA
        ;               // Fall through to label ?Subroutine2

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
        LDS     R16, _A_ADCSRA
        ANDI    R16, 0x3F
        RJMP    ?Subroutine15
//   67 }
//   68 
//   69 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   70 void CAdc::Disable(void)
??Disable:
//   71 {
//   72     // Выключаем АЦП.
//   73     ADCSRA &= ~(BIT(ADEN) | BIT(ADSC));
        RCALL   ?Subroutine2
//   74     // Включаем режим пониженного энергопотребления.
//   75     PRR |= BIT(PRADC);
??CrossCallReturnLabel_13:
        LDS     R16, 100
        ORI     R16, 0x01
        STS     100, R16
//   76 }
        RET
        REQUIRE _A_ADCSRA
        REQUIRE _A_PRR
//   77 
//   78 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   79 void CAdc::Enable(void)
??Enable:
//   80 {
//   81     // Отключаем режим пониженного энергопотребления.
//   82     PRR &= ~BIT(PRADC);
        LDS     R16, 100
        ANDI    R16, 0xFE
        STS     100, R16
//   83     // Включаем АЦП.
//   84     ADCSRA |= BIT(ADEN);
        LDS     R16, 122
        ORI     R16, 0x80
        STS     122, R16
//   85 }
        RET
        REQUIRE _A_PRR
        REQUIRE _A_ADCSRA
//   86 
//   87 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   88 uint16_t CAdc::GetMeasureValue(void)
??GetMeasureValue:
//   89 {
//   90     uint16_t uiData;
//   91     uiData = (static_cast<uint16_t>(ADCL));
        LDS     R16, _A_ADC
//   92     uiData |= (static_cast<uint16_t>(ADCH) << 8);
//   93     return uiData;
        LDS     R17, 121
        RET
        REQUIRE _A_ADC
//   94 };
//   95 
//   96 ////-----------------------------------------------------------------------------------------------------
//   97 //#pragma vector = ADC_vect
//   98 //__interrupt void CAdc::SIG_ADC(void)
//   99 //{
//  100 //    m_fbMeasureIsComlete = true;
//  101 //}
//  102 ////-----------------------------------------------------------------------------------------------------
//  103 
//  104 
//  105 
//  106 
//  107 
//  108 volatile uint8_t* CUart::m_UBRRH;
//  109 volatile uint8_t* CUart::m_UBRRL;
//  110 volatile uint8_t* CUart::m_UCSRA;
//  111 volatile uint8_t* CUart::m_UCSRB;
//  112 volatile uint8_t* CUart::m_UCSRC;
//  113 volatile uint8_t* CUart::m_UDR;
//  114 volatile uint8_t* CUart::m_rs485ddr;
//  115 volatile uint8_t CUart::m_rs485ddpin;
//  116 volatile uint8_t* CUart::m_rs485port;
//  117 volatile uint8_t CUart::m_rs485pin;
//  118 
//  119 uint8_t* CUart::m_puiTxBuffer;
//  120 uint16_t CUart::m_nuiTxBuffByteCounter;
//  121 uint8_t* CUart::m_puiRxBuffer;
//  122 uint16_t CUart::m_nuiRxBuffByteCounter;
//  123 uint8_t CUart::m_auiIntermediateBuff[UART_INTERMEDIATE_BUFF_LENGTH];
//  124 bool CUart::m_bfByteIsReceived;
//  125 bool CUart::m_bfFrameIsSended;
//  126 bool CUart::m_bfRxBuffOverflow;
//  127 
//  128 ////-----------------------------------------------------------------------------------------------------
//  129 //CUart::CUart()
//  130 //{
//  131 //
//  132 //}
//  133 
//  134 ////-----------------------------------------------------------------------------------------------------
//  135 //CUart::CUart(volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
//  136 //             volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
//  137 //             volatile uint8_t *ucsrc, volatile uint8_t *udr,
//  138 //             volatile uint8_t *rs485ddr, volatile uint8_t rs485ddpin,
//  139 //             volatile uint8_t *rs485port, volatile uint8_t rs485pin) :
//  140 //    m_UBRRH(ubrrh), m_UBRRL(ubrrl), m_UCSRA(ucsra),
//  141 //    m_UCSRB(ucsrb), m_UCSRC(ucsrc), m_UDR(udr),
//  142 //    m_rs485ddr(rs485ddr), m_rs485ddpin(rs485ddpin), m_rs485port(rs485port), m_rs485pin(rs485pin)
//  143 //{
//  144 //    if (m_rs485ddr)
//  145 //    {
//  146 //        *m_rs485ddr |= Bit(m_rs485ddpin);
//  147 //        *m_rs485port &= ~(Bit(m_rs485pin));
//  148 //    }
//  149 //}
//  150 
//  151 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  152 void CUart::UartBind(volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
??UartBind:
//  153                      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
//  154                      volatile uint8_t *ucsrc, volatile uint8_t *udr,
//  155                      volatile uint8_t *rs485ddr, volatile uint8_t rs485ddpin,
//  156                      volatile uint8_t *rs485port, volatile uint8_t rs485pin)
//  157 {
        RCALL   ?Subroutine3
//  158     m_UBRRH = ubrrh;
??CrossCallReturnLabel_31:
        RCALL   ?Subroutine4
//  159     m_UBRRL = ubrrl;
//  160     m_UCSRA = ucsra;
??CrossCallReturnLabel_0:
        STD     Z+4, R20
        STD     Z+5, R21
//  161     m_UCSRB = ucsrb;
        STD     Z+6, R22
        STD     Z+7, R23
//  162     m_UCSRC = ucsrc;
        LDD     R16, Y+4
        LDD     R17, Y+5
        STD     Z+8, R16
        STD     Z+9, R17
//  163     m_UDR = udr;
        LDD     R16, Y+6
        LDD     R17, Y+7
        STD     Z+10, R16
        STD     Z+11, R17
//  164 //    m_rs485ddr = rs485ddr;
//  165 //    m_rs485ddpin = rs485ddpin;
//  166 //    m_rs485port = rs485port;
//  167 //    m_rs485pin = rs485pin;
//  168 //
//  169 //    if (m_rs485ddr)
//  170 //    {
//  171 //        *m_rs485ddr |= Bit(m_rs485ddpin);
//  172 //        *m_rs485port &= ~(Bit(m_rs485pin));
//  173 //    }
//  174 }
        LDI     R30, 14
        RJMP    ?EPILOGUE_B4_L09

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
        RCALL   ?PROLOGUE4_L09
        REQUIRE ??Subroutine25_0
        ;               // Fall through to label ??Subroutine25_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine25_0:
        LDI     R30, LOW(??m_UBRRH)
        LDI     R31, (??m_UBRRH) >> 8
        RET
//  175 
//  176 ////-----------------------------------------------------------------------------------------------------
//  177 //CUart::~CUart()
//  178 //{
//  179 //
//  180 //}
//  181 
//  182 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  183 void CUart::Init(uint32_t ulBaudRate,
??Init_1:
//  184                  uint8_t ucParity,
//  185                  uint8_t ucDataBits,
//  186                  uint8_t ucStopBit,
//  187                  uint8_t *puiRxBuffer,
//  188                  uint8_t *puiTxBuffer)
//  189 {
        RCALL   ?PROLOGUE5_L09
        REQUIRE ?Register_R4_is_cg_reg
        MOV     R24, R20
        MOV     R4, R21
        MOV     R25, R22
//  190     m_puiRxBuffer = puiRxBuffer;
        LDI     R26, LOW(??m_UBRRH)
        LDI     R27, (??m_UBRRH) >> 8
        LDD     R20, Y+5
        LDD     R21, Y+6
        MOVW    R31:R30, R27:R26
        STD     Z+16, R20
        STD     Z+17, R21
//  191     m_puiTxBuffer = puiTxBuffer;
        LDD     R20, Y+7
        LDD     R21, Y+8
        STD     Z+12, R20
        STD     Z+13, R21
//  192 
//  193     *m_UCSRA = 0;
        LDD     R20, Z+4
        LDD     R31, Z+5
        RCALL   ?Subroutine8
//  194     *m_UCSRB = 0;
??CrossCallReturnLabel_2:
        LDD     R20, Z+6
        LDD     R31, Z+7
        RCALL   ?Subroutine8
//  195     *m_UCSRC = 0;
??CrossCallReturnLabel_3:
        LDD     R20, Z+8
        LDD     R31, Z+9
        MOV     R30, R20
        LDI     R20, 0
        ST      Z, R20
//  196 
//  197 
//  198     /* Set the baud rate */
//  199     uint16_t uiBaudRateTemp = (F_CPU / (ulBaudRate * 16UL) - 1);
        LDI     R20, 4
        RCALL   ?L_SHL_L03
        MOVW    R21:R20, R17:R16
        MOVW    R23:R22, R19:R18
        LDI     R16, 0
        LDI     R17, 0
        LDI     R18, 225
        LDI     R19, 0
        RCALL   ?UL_DIVMOD_L03
        MOVW    R19:R18, R17:R16
        SUBI    R18, 1
        SBCI    R19, 0
//  200     *m_UBRRL = uiBaudRateTemp;
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+2
        LDD     R31, Z+3
        MOV     R30, R16
        ST      Z, R18
//  201     *m_UBRRH = (uiBaudRateTemp >> 8);
        RCALL   ?Subroutine10
??CrossCallReturnLabel_4:
        SBIW    R27:R26, 1
        ST      Z, R19
//  202 
//  203     /* Set data bits (7, 8 bits) */
//  204     switch (ucDataBits)
        MOV     R16, R4
        SUBI    R16, 7
        BREQ    ??Init_4
        DEC     R16
        BRNE    ??Init_5
//  205     {
//  206     case 8:
//  207         *m_UCSRC |= (1 << UCSZ00) | (1 << UCSZ01);
        RCALL   ?Subroutine5
??CrossCallReturnLabel_26:
        ORI     R16, 0x06
        RJMP    ??Init_6
//  208         break;
//  209     case 7:
//  210         *m_UCSRC |= (1 << UCSZ01);
??Init_4:
        RCALL   ?Subroutine5
??CrossCallReturnLabel_27:
        ORI     R16, 0x04
??Init_6:
        ST      Z, R16
//  211         break;
//  212     }
//  213 
//  214     /* Set parity */
//  215     if (ucParity == 'N')
??Init_5:
        CPI     R24, 78
        BREQ    ??Init_7
//  216     {
//  217         /* None */
//  218     }
//  219     else if (ucParity == 'E')
        CPI     R24, 69
        RCALL   ?Subroutine5
??CrossCallReturnLabel_28:
        BRNE    ??Init_8
//  220     {
//  221         /* Even */
//  222         *m_UCSRC |= (1 << UPM01);
        ORI     R16, 0x20
        RJMP    ??Init_9
//  223     }
//  224     else
//  225     {
//  226         /* Odd */
//  227         *m_UCSRC |= (1 << UPM01) | (1 << UPM00);
??Init_8:
        ORI     R16, 0x30
??Init_9:
        ST      Z, R16
//  228     }
//  229 
//  230     /* Stop bit (1 or 2) */
//  231     if (ucStopBit == 1)
??Init_7:
        CPI     R25, 1
        BRNE    ??Init_10
//  232     {
//  233         *m_UCSRC &= ~(1 << USBS0);
        RCALL   ?Subroutine7
//  234     }
??CrossCallReturnLabel_24:
        ANDI    R16, 0xF7
        RJMP    ??Init_11
//  235     else if (ucStopBit == 2) /* 2 */
??Init_10:
        CPI     R25, 2
        BRNE    ??Init_12
//  236     {
//  237         *m_UCSRC |= (1 << USBS0);
        RCALL   ?Subroutine7
//  238     }
??CrossCallReturnLabel_25:
        ORI     R16, 0x08
??Init_11:
        ST      X, R16
//  239 }
??Init_12:
        LDI     R30, 9
        RJMP    ?EPILOGUE_B5_L09

        RSEG CODE:CODE:NOROOT(1)
?Subroutine8:
        MOV     R30, R20
        LDI     R20, 0
        ST      Z, R20
        MOVW    R31:R30, R27:R26
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine7:
        MOVW    R31:R30, R27:R26
        LDD     R26, Z+8
        LDD     R27, Z+9
        REQUIRE ?Subroutine18
        ;               // Fall through to label ?Subroutine18

        RSEG CODE:CODE:NOROOT(1)
?Subroutine18:
        LD      R16, X
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine5:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+8
        LDD     R31, Z+9
        MOV     R30, R16
        REQUIRE ?Subroutine19
        ;               // Fall through to label ?Subroutine19

        RSEG CODE:CODE:NOROOT(1)
?Subroutine19:
        LD      R16, Z
        RET
//  240 
//  241 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  242 void CUart::Reset(void)
??Reset:
//  243 {
//  244     m_nuiRxBuffByteCounter = 0;
        RCALL   ??Subroutine25_0
??CrossCallReturnLabel_33:
        LDI     R16, 0
        STD     Z+18, R16
        STD     Z+19, R16
//  245     m_bfByteIsReceived = 0;
        STD     Z+36, R16
//  246     m_bfFrameIsSended = 0;
        STD     Z+37, R16
//  247     m_bfRxBuffOverflow = 0;
        STD     Z+38, R16
//  248 }
        RET
//  249 
//  250 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  251 void CUart::ReceiveEnable(void)
??ReceiveEnable:
//  252 {
        RCALL   ?Subroutine0
//  253     *m_UCSRA |= (1 << RXC0);
??CrossCallReturnLabel_18:
        ORI     R16, 0x80
        RCALL   ?Subroutine6
//  254     *m_UCSRB |= (1 << RXEN0) | (1 << RXCIE0);
??CrossCallReturnLabel_21:
        ORI     R16, 0x90
        RJMP    ?Subroutine22
//  255 }
//  256 
//  257 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  258 void CUart::ReceiveDisable(void)
??ReceiveDisable:
//  259 {
        RCALL   ?PROLOGUE4_L09
//  260     *m_UCSRB &= ~((1 << RXEN0) | (1 << RXCIE0));
        LDI     R26, LOW((??m_UBRRH + 6))
        LDI     R27, HIGH((??m_UBRRH + 6))
        RCALL   ?Subroutine10
??CrossCallReturnLabel_5:
        LD      R16, Z
        ANDI    R16, 0x6F
        ST      Z, R16
//  261 }
        RJMP    ??Subroutine26_0
//  262 
//  263 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  264 void CUart::TransmitEnable(void)
??TransmitEnable:
//  265 {
        RCALL   ?Subroutine0
//  266     *m_UCSRA |= (1 << TXC0) | (1 << UDRE0);
??CrossCallReturnLabel_19:
        ORI     R16, 0x60
        RCALL   ?Subroutine6
//  267     *m_UCSRB |= (1 << TXEN0) | (1 << UDRIE0);
??CrossCallReturnLabel_22:
        ORI     R16, 0x28
        RJMP    ?Subroutine22

        RSEG CODE:CODE:NOROOT(1)
?Subroutine6:
        ST      X, R16
        LDD     R26, Z+6
        LDD     R27, Z+7
        RJMP    ?Subroutine18

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
        RCALL   ?PROLOGUE4_L09
        LDI     R30, LOW(??m_UBRRH)
        LDI     R31, (??m_UBRRH) >> 8
        LDD     R26, Z+4
        LDD     R27, Z+5
        RJMP    ?Subroutine18
//  268 }
//  269 
//  270 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  271 void CUart::TransmitDisable(void)
??TransmitDisable:
//  272 {
        RCALL   ?Subroutine0
//  273     *m_UCSRA &= ~(1 << UDRE0);
??CrossCallReturnLabel_20:
        ANDI    R16, 0xDF
        RCALL   ?Subroutine6
//  274     *m_UCSRB &= ~((1 << TXEN0) | (1 << TXCIE0) | (1 << UDRIE0));
??CrossCallReturnLabel_23:
        ANDI    R16, 0x97
        REQUIRE ?Subroutine22
        ;               // Fall through to label ?Subroutine22

        RSEG CODE:CODE:NOROOT(1)
?Subroutine22:
        ST      X, R16
//  275 }
        REQUIRE ??Subroutine26_0
        ;               // Fall through to label ??Subroutine26_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine26_0:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  276 
//  277 ////-----------------------------------------------------------------------------------------------------
//  278 //void CUart::Rs485RtsOn(void)
//  279 //{
//  280 //    *m_rs485port |= (1 << m_rs485pin);
//  281 //}
//  282 //
//  283 ////-----------------------------------------------------------------------------------------------------
//  284 //void CUart::Rs485RtsOff(void)
//  285 //{
//  286 //    *m_rs485port &= ~(1 << m_rs485pin);
//  287 //}
//  288 
//  289 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  290 int16_t CUart::Write(uint8_t *puiSource, uint16_t uiLength)
??Write:
//  291 {
//  292     m_puiTxBuffer = (uint8_t*)puiSource;
        RCALL   ??Subroutine25_0
??CrossCallReturnLabel_34:
        STD     Z+12, R16
        STD     Z+13, R17
//  293     m_nuiTxBuffByteCounter = uiLength;
        STD     Z+14, R18
        STD     Z+15, R19
//  294 
//  295 ////    if (m_rs485ddr)
//  296 ////    {
//  297 ////        Rs485RtsOn();
//  298 ////    }
//  299 
//  300     return 1;
        LDI     R16, 1
        RJMP    ?Subroutine17
//  301 }
//  302 
//  303 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  304 int16_t CUart::Read(uint8_t *puiDestination, uint16_t uiLength)
??Read:
//  305 {
        RCALL   ?Subroutine3
//  306     m_bfByteIsReceived = 0;
??CrossCallReturnLabel_32:
        LDI     R20, 0
        STD     Z+36, R20
//  307 
//  308     if (m_bfRxBuffOverflow)
        LDD     R20, Z+38
        TST     R20
        BRNE    ??Read_2
//  309     {
//  310         return -1;
//  311     }
//  312 
//  313     if (uiLength <= m_nuiRxBuffByteCounter)
        LDD     R20, Z+18
        LDD     R21, Z+19
        CP      R20, R18
        CPC     R21, R19
        BRCS    ??Read_3
//  314     {
//  315         return -1;
??Read_2:
        LDI     R16, 255
        LDI     R17, 255
        RJMP    ??Read_4
//  316     }
//  317     else if (m_nuiRxBuffByteCounter)
??Read_3:
        OR      R20, R21
        BREQ    ??Read_5
//  318     {
//  319         CPlatform::InterruptDisable();
        CLI
//  320 
//  321         for (int16_t i = 0; i < m_nuiRxBuffByteCounter; i++)
        LDI     R24, 0
        LDI     R25, 0
        RJMP    ??Read_6
//  322         {
//  323             puiDestination[i] = m_auiIntermediateBuff[i];
??Read_7:
        MOVW    R27:R26, R31:R30
        ADD     R26, R24
        ADC     R27, R25
        ADIW    R27:R26, 20
        LD      R18, X
        MOVW    R27:R26, R17:R16
        ADD     R26, R24
        ADC     R27, R25
        ST      X, R18
//  324         }
        ADIW    R25:R24, 1
??Read_6:
        LDD     R18, Z+18
        LDD     R19, Z+19
        CP      R24, R18
        CPC     R25, R19
        BRCS    ??Read_7
//  325 
//  326         uint8_t uiCounter = m_nuiRxBuffByteCounter;
        MOV     R16, R18
//  327         m_nuiRxBuffByteCounter = 0;
        LDI     R17, 0
        STD     Z+18, R17
        STD     Z+19, R17
//  328 
//  329         CPlatform::InterruptEnable();
        SEI
//  330 
//  331         return uiCounter;
//  332     }
        RJMP    ??Read_4
//  333     else if (0 == m_nuiRxBuffByteCounter)
//  334     {
//  335         return 0;
//  336     }
//  337     return 0;
??Read_5:
        LDI     R16, 0
        LDI     R17, 0
??Read_4:
        RJMP    ??Subroutine26_0
//  338 }
//  339 //
//  340 ////-----------------------------------------------------------------------------------------------------
//  341 //void CUart::RecvInterruptHandler(void)
//  342 //{
//  343 //    // промежуточный буфер приёма переполнен?
//  344 //    if (m_nuiRxBuffByteCounter >=
//  345 //            UART_MAX_BUFF_LENGTH)
//  346 //    {
//  347 //        m_bfRxBuffOverflow = 1;
//  348 //        // не инкрементируем pucUsartRxBuff, чтобы не выйти за границы буфера.
//  349 //        m_bfByteIsReceived = 1;
//  350 //    }
//  351 //    else
//  352 //    {
//  353 //        m_auiIntermediateBuff[m_nuiRxBuffByteCounter++] = *m_UDR;
//  354 //        m_bfByteIsReceived = 1;
//  355 //    }
//  356 //}
//  357 
//  358 ////-----------------------------------------------------------------------------------------------------
//  359 //void CUart::UdreInterruptHandler(void)
//  360 //{
//  361 //    if (m_nuiTxBuffByteCounter == 0)
//  362 //    {
//  363 //        *m_UCSRB &= ~((1 << UDRIE0));
//  364 ////        *m_UCSRA |= (1 << TXC0);
//  365 //        *m_UCSRB |= (1 << TXCIE0);
//  366 //        return;
//  367 //    }
//  368 //    *m_UDR = *m_puiTxBuffer++;
//  369 //    m_nuiTxBuffByteCounter--;
//  370 //}
//  371 //
//  372 ////-----------------------------------------------------------------------------------------------------
//  373 //void CUart::TxcInterruptHandler(void)
//  374 //{
//  375 //////    *m_UCSRB &= ~((1 << TXEN0) | (1 << TXCIE0));
//  376 ////
//  377 //////    if (m_rs485ddr)
//  378 //////    {
//  379 //////        Rs485RtsOff();
//  380 //////    }
//  381 ////    CMvsn21::MeasureFlowControlSet(CMvsn21::FSM_START);
//  382 //////    *m_UCSRA |= (1 << RXC0);
//  383 //////    *m_UCSRB |= (1 << RXEN0) | (1 << RXCIE0);
//  384 //    m_bfFrameIsSended = 1;
//  385 //}
//  386 
//  387 //-----------------------------------------------------------------------------------------------------
//  388 // Прерывание по завершению приема UART
//  389 #pragma vector = USART_RX_vect
//  390 //__interrupt void CUart::__URXComplete(void)

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SIG_UART0_RECV, "interrupt"
//  391 __interrupt void SIG_UART0_RECV(void)
??SIG_UART0_RECV:
//  392 {
        ST      -Y, R27
        ST      -Y, R26
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R19
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R19, 0x3F
//  393 //    CUart::RecvInterruptHandler();
//  394     // промежуточный буфер приёма переполнен?
//  395     if (CUart::m_nuiRxBuffByteCounter >=
//  396             CUart::UART_MAX_BUFF_LENGTH)
        LDI     R26, LOW(??m_UBRRH)
        LDI     R27, (??m_UBRRH) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+18
        LDD     R17, Z+19
        CPI     R16, 64
        LDI     R18, 0
        CPC     R17, R18
        BRCS    ??SIG_UART0_RECV_1
//  397     {
//  398         CUart::m_bfRxBuffOverflow = 1;
        LDI     R16, 1
        STD     Z+38, R16
//  399         // не инкрементируем pucUsartRxBuff, чтобы не выйти за границы буфера.
//  400         CUart::m_bfByteIsReceived = 1;
        RJMP    ??SIG_UART0_RECV_2
//  401     }
//  402     else
//  403     {
//  404         CUart::m_auiIntermediateBuff[CUart::m_nuiRxBuffByteCounter++] = *CUart::m_UDR;
??SIG_UART0_RECV_1:
        ADIW    R27:R26, 10
        RCALL   ?Subroutine10
??CrossCallReturnLabel_6:
        SBIW    R27:R26, 11
        LD      R18, Z
        MOVW    R31:R30, R27:R26
        ADD     R30, R16
        ADC     R31, R17
        STD     Z+20, R18
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+18
        LDD     R17, Z+19
        SUBI    R16, 255
        SBCI    R17, 255
        STD     Z+18, R16
        STD     Z+19, R17
//  405         CUart::m_bfByteIsReceived = 1;
??SIG_UART0_RECV_2:
        LDI     R16, 1
        STD     Z+36, R16
//  406     }
//  407 }
        OUT     0x3F, R19
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R19, Y+
        LD      R30, Y+
        LD      R31, Y+
        REQUIRE ?Subroutine23
        ;               // Fall through to label ?Subroutine23

        RSEG CODE:CODE:NOROOT(1)
?Subroutine23:
        LD      R26, Y+
        LD      R27, Y+
        RETI

        RSEG CODE:CODE:NOROOT(1)
?Subroutine10:
        LD      R30, X+
        LD      R31, X
        RET
//  408 
//  409 //-----------------------------------------------------------------------------------------------------
//  410 // Прерывание по пустому регистру данных UDR
//  411 #pragma vector = USART_UDRE_vect
//  412 //__interrupt void CUart::__UDREmpty(void)

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SIG_UART0_DATA, "interrupt"
//  413 __interrupt void SIG_UART0_DATA(void)
??SIG_UART0_DATA:
//  414 {
        ST      -Y, R27
        ST      -Y, R26
        RCALL   ?Subroutine11
//  415 //    CUart::UdreInterruptHandler();
//  416     if (CUart::m_nuiTxBuffByteCounter == 0)
??CrossCallReturnLabel_9:
        LDI     R26, LOW(??m_UBRRH)
        LDI     R27, (??m_UBRRH) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+14
        LDD     R17, Z+15
        OR      R16, R17
        BRNE    ??SIG_UART0_DATA_1
//  417     {
//  418         *CUart::m_UCSRB &= ~((1 << UDRIE0));
        ADIW    R27:R26, 6
        RCALL   ?Subroutine9
??CrossCallReturnLabel_29:
        ANDI    R16, 0xDF
        ST      Z, R16
//  419         *CUart::m_UCSRA |= (1 << TXC0);
        RCALL   ?Subroutine10
??CrossCallReturnLabel_7:
        SBIW    R27:R26, 5
        LD      R16, Z
        ORI     R16, 0x40
        ST      Z, R16
//  420         *CUart::m_UCSRB |= (1 << TXCIE0);
        MOVW    R31:R30, R27:R26
        LDD     R26, Z+6
        LDD     R27, Z+7
        LD      R16, X
        ORI     R16, 0x40
        ST      X, R16
//  421         return;
        RJMP    ??SIG_UART0_DATA_2
//  422     }
//  423     *CUart::m_UDR = *CUart::m_puiTxBuffer++;
??SIG_UART0_DATA_1:
        ADIW    R27:R26, 12
        RCALL   ?Subroutine9
??CrossCallReturnLabel_30:
        RCALL   ?Subroutine10
??CrossCallReturnLabel_8:
        SBIW    R27:R26, 11
        ST      Z, R16
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+12
        LDD     R17, Z+13
        SUBI    R16, 255
        SBCI    R17, 255
        STD     Z+12, R16
        STD     Z+13, R17
//  424     CUart::m_nuiTxBuffByteCounter--;
        LDD     R16, Z+14
        LDD     R17, Z+15
        SUBI    R16, 1
        SBCI    R17, 0
        STD     Z+14, R16
        STD     Z+15, R17
//  425 }
??SIG_UART0_DATA_2:
        RCALL   ?Subroutine12
??CrossCallReturnLabel_11:
        RJMP    ?Subroutine23

        RSEG CODE:CODE:NOROOT(1)
?Subroutine9:
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 3
        RJMP    ?Subroutine19
//  426 
//  427 //-----------------------------------------------------------------------------------------------------
//  428 // Прерывание по завершению передачи UART
//  429 #pragma vector = USART_TX_vect

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SIG_UART0_TXC, "interrupt"
//  430 __interrupt void SIG_UART0_TXC(void)
??SIG_UART0_TXC:
//  431 //__interrupt void CUart::__UTXComplete(void)
//  432 {
        ST      -Y, R16
//  433 //    CUart::TxcInterruptHandler();
//  434 
//  435 ////    if (m_rs485ddr)
//  436 ////    {
//  437 ////        Rs485RtsOff();
//  438 ////    }
//  439 
//  440     CUart::m_bfFrameIsSended = 1;
        LDI     R16, 1
        STS     (??m_UBRRH + 37), R16
//  441 }
        LD      R16, Y+
        RETI
//  442 
//  443 //-----------------------------------------------------------------------------------------------------
//  444 
//  445 
//  446 
//  447 
//  448 
//  449 ////----------------------------------------- EEPROM ----------------------------------------------------------------
//  450 //CEeprom::CEeprom()
//  451 //{
//  452 //
//  453 //}
//  454 //
//  455 ////-----------------------------------------------------------------------------------------------------
//  456 //CEeprom::~CEeprom()
//  457 //{
//  458 //
//  459 //}
//  460 
//  461 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  462 uint8_t CEeprom::ReadByte(uint16_t ui16EepromSourse)
??ReadByte:
??ReadByte_1:
//  463 {
//  464     __watchdog_reset();
//  465     while (BitIsSet(EECR, EEPE))
//  466     {
//  467         __watchdog_reset();
        WDR
//  468     }
        SBIC    0x1F, 0x01
        RJMP    ??ReadByte_1
//  469     __disable_interrupt();
        CLI
//  470     EEAR = ui16EepromSourse;
        OUT     0x22, R17
        OUT     0x21, R16
//  471     SetBit(EECR, EERE);
        SBI     0x1F, 0x00
//  472     __enable_interrupt();
        SEI
//  473     return EEDR;
        IN      R16, 0x20
        RET
        REQUIRE _A_EECR
        REQUIRE _A_EEAR
        REQUIRE _A_EEDR
//  474 }
//  475 
//  476 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  477 void CEeprom::WriteByte(uint16_t ui16EepromDestination, uint8_t ucData)
??WriteByte:
??WriteByte_1:
//  478 {
//  479     __watchdog_reset();
//  480     while (BitIsSet(EECR, EEPE))
//  481     {
//  482         __watchdog_reset();
        WDR
//  483     }
        SBIC    0x1F, 0x01
        RJMP    ??WriteByte_1
//  484     __disable_interrupt();
        CLI
//  485     EEAR = ui16EepromDestination;
        OUT     0x22, R17
        OUT     0x21, R16
//  486     EEDR = ucData;
        OUT     0x20, R18
//  487     EECR |= (1<<EEMPE);
        SBI     0x1F, 0x02
//  488     EECR |= (1<<EEPE);
        SBI     0x1F, 0x01
//  489     __enable_interrupt();
        SEI
//  490 }
        RET
        REQUIRE _A_EECR
        REQUIRE _A_EEAR
        REQUIRE _A_EEDR
//  491 
//  492 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  493 uint8_t CEeprom::Read(uint8_t *pucRamDestination, uint16_t uiEepromSourse, uint16_t nuiLength)
??Read_1:
//  494 {
        MOVW    R31:R30, R17:R16
        RJMP    ??Read_8
//  495     while (nuiLength != 0)
//  496     {
//  497         *pucRamDestination++ = ReadByte(uiEepromSourse++);
??Read_9:
        MOVW    R17:R16, R19:R18
        RCALL   ??ReadByte
        SUBI    R18, 255
        SBCI    R19, 255
        ST      Z+, R16
//  498         nuiLength--;
        SUBI    R20, 1
        SBCI    R21, 0
//  499     }
??Read_8:
        MOV     R16, R20
        OR      R16, R21
        BRNE    ??Read_9
//  500     return 1;
        LDI     R16, 1
        RET
//  501 }
//  502 
//  503 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  504 uint8_t CEeprom::Write(uint16_t uiEepromDestination, uint8_t *pucRamSourse, uint16_t nuiLength)
??Write_1:
//  505 {
        RCALL   ?PROLOGUE2_L09
        MOVW    R25:R24, R17:R16
        MOVW    R31:R30, R19:R18
        RJMP    ??Write_2
//  506     while (nuiLength != 0)
//  507     {
//  508         WriteByte((uiEepromDestination++), (*pucRamSourse++));
??Write_3:
        LD      R18, Z+
        MOVW    R17:R16, R25:R24
        RCALL   ??WriteByte
        ADIW    R25:R24, 1
//  509         nuiLength--;
        SUBI    R20, 1
        SBCI    R21, 0
//  510     }
??Write_2:
        MOV     R16, R20
        OR      R16, R21
        BRNE    ??Write_3
//  511     return 1;
        LDI     R16, 1
        REQUIRE ?Subroutine24
        ;               // Fall through to label ?Subroutine24
//  512 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine24:
        LDI     R30, 2
        RJMP    ?EPILOGUE_B2_L09
//  513 //-----------------------------------------------------------------------------------------------------
//  514 
//  515 
//  516 
//  517 
//  518 
//  519 //----------------------------------------- CSpi ----------------------------------------------------------------
//  520 uint8_t CSpi::m_uiExchangeByte;
//  521 uint8_t* CSpi::m_puiRxBuffer;
//  522 uint8_t* CSpi::m_puiTxBuffer;
//  523 uint16_t CSpi::m_nuiBuffByteCounter;
//  524 uint16_t CSpi::m_uiReceivedByteCounter;
//  525 bool CSpi::m_bfByteIsReceived;
//  526 bool CSpi::m_bfByteIsTransmited;
//  527 bool CSpi::m_bfDataExchangeInProgress;
//  528 bool CSpi::m_bfDataExchangeIsOccur;
//  529 bool CSpi::m_bfRxBuffOverflow;
//  530 uint8_t CSpi::m_auiSpiRxBuffer[];
//  531 uint8_t CSpi::m_auiSpiTxBuffer[];
//  532 
//  533 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  534 CSpi::CSpi()
??CSpi:
        REQUIRE ?Subroutine1
        ;               // Fall through to label ?Subroutine1

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
//  535 {
        LDI     R18, LOW(??__vtbl)
        LDI     R19, (??__vtbl) >> 8
        MOVW    R31:R30, R17:R16
        ST      Z, R18
        STD     Z+1, R19
        RET
//  536 
//  537 }
//  538 
//  539 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  540 CSpi::~CSpi()
`?~CSpi`:
//  541 {
        MOV     R20, R16
        OR      R20, R17
        BREQ    `?~CSpi_1`
        BST     R18, 0
        BRTC    `?~CSpi_1`
//  542 
//  543 }
        RCALL   `??operator delete`
`?~CSpi_1`:
        RET
//  544 
//  545 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  546 void CSpi::Init(uint8_t *puiRxBuffer, uint8_t *puiTxBuffer)
??Init_2:
//  547 {
//  548     m_puiRxBuffer = puiRxBuffer;
        LDI     R30, LOW(??m_puiRxBuffer_1)
        LDI     R31, (??m_puiRxBuffer_1) >> 8
        RCALL   ?Subroutine4
//  549     m_puiTxBuffer = puiTxBuffer;
//  550     // Slave mode.
//  551     DDRB  |= (Bit(SPI_MISO) | Bit(DDB1));
??CrossCallReturnLabel_1:
        IN      R16, 0x04
        ORI     R16, 0x12
        OUT     0x04, R16
//  552     SPCR |= (1 << SPR1);
        IN      R16, 0x2C
        ORI     R16, 0x02
        REQUIRE ?Subroutine20
        REQUIRE _A_DDRB
        REQUIRE _A_SPCR
        ;               // Fall through to label ?Subroutine20
//  553 };

        RSEG CODE:CODE:NOROOT(1)
?Subroutine20:
        OUT     0x2C, R16
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine4:
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
        RET
//  554 
//  555 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  556 void CSpi::Enable(void)
??Enable_1:
//  557 {
//  558     // Slave mode.
//  559     // разрешим SS.
//  560     PORTB &= ~Bit(PB1);
        CBI     0x05, 0x01
//  561     // разрешим SPI.
//  562     // разрешим прерывание SPI_STC.
//  563     SPCR |= ((1 << SPE) | (1 << SPIE));
        IN      R16, 0x2C
        ORI     R16, 0xC0
        OUT     0x2C, R16
//  564     SPDR = 0;
        LDI     R16, 0
        REQUIRE ?Subroutine21
        REQUIRE _A_PORTB
        REQUIRE _A_SPCR
        REQUIRE _A_SPDR
        ;               // Fall through to label ?Subroutine21
//  565 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine21:
        OUT     0x2E, R16
        RET
//  566 
//  567 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  568 void CSpi::Disable(void)
??Disable_1:
//  569 {
//  570     // Slave mode.
//  571     // запретим SS.
//  572     PORTB |= Bit(PB1);
        SBI     0x05, 0x01
//  573     // запретим прерывание SPI_STC.
//  574     SPCR &= ~((1 << SPE) | (1 << SPIE));
        IN      R16, 0x2C
        ANDI    R16, 0x3F
        RJMP    ?Subroutine20
        REQUIRE _A_PORTB
        REQUIRE _A_SPCR
//  575 }
//  576 
//  577 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  578 void CSpi::Reset(void)
??Reset_1:
//  579 {
//  580     m_nuiBuffByteCounter = 0;
        LDI     R30, LOW(??m_nuiBuffByteCounter)
        LDI     R31, (??m_nuiBuffByteCounter) >> 8
        LDI     R16, 0
        ST      Z, R16
        STD     Z+1, R16
//  581     m_uiReceivedByteCounter = 0;
        STD     Z+2, R16
        STD     Z+3, R16
//  582     m_bfByteIsReceived = 0;
        STD     Z+5, R16
//  583     m_bfByteIsTransmited = 0;
        STD     Z+6, R16
//  584     m_bfDataExchangeInProgress = 0;
        STD     Z+7, R16
//  585     m_bfDataExchangeIsOccur = 0;
        STD     Z+8, R16
//  586     m_bfRxBuffOverflow = 0;
        STD     Z+9, R16
//  587     m_uiExchangeByte = 0;
        STD     Z+4, R16
//  588 }
        RET
//  589 
//  590 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  591 void CSpi::SendByte(uint8_t uiData)
??SendByte:
//  592 {
//  593     uint8_t uiGuardCounter = 0;
        LDI     R17, 100
        RJMP    ??SendByte_1
//  594 
//  595     while(!(SPSR & BIT(SPIF)))
//  596     {
//  597         if (uiGuardCounter < 100)
//  598         {
//  599             uiGuardCounter++;
??SendByte_2:
        DEC     R17
//  600         }
??SendByte_1:
        IN      R18, 0x2D
        SBRC    R18, 7
        RJMP    ??SendByte_3
        TST     R17
        BRNE    ??SendByte_2
//  601         else
//  602         {
//  603             return;
        RET
//  604         }
//  605     };
//  606 
//  607     SPDR = uiData;
??SendByte_3:
        RJMP    ?Subroutine21
        REQUIRE _A_SPSR
        REQUIRE _A_SPDR
//  608 }
//  609 
//  610 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  611 int16_t CSpi::Exchange(void)
??Exchange:
//  612 {
        RCALL   ?PROLOGUE2_L09
//  613     m_bfByteIsReceived = 0;
        LDI     R30, LOW(??m_nuiBuffByteCounter)
        LDI     R31, (??m_nuiBuffByteCounter) >> 8
        LDI     R16, 0
        STD     Z+5, R16
//  614 
//  615     if (m_bfRxBuffOverflow)
        LDD     R16, Z+9
        TST     R16
        BRNE    ??Exchange_1
//  616     {
//  617         return -1;
//  618     }
//  619     if (BUFFER_LENGTH <= m_nuiBuffByteCounter)
        LD      R24, Z
        LDD     R25, Z+1
        SBIW    R25:R24, 16
        BRCS    ??Exchange_2
//  620     {
//  621         return -1;
??Exchange_1:
        LDI     R16, 255
        LDI     R17, 255
        RJMP    ??Exchange_3
//  622     }
//  623     else if (m_nuiBuffByteCounter)
??Exchange_2:
        LD      R16, Z
        LDD     R17, Z+1
        OR      R16, R17
        BREQ    ??Exchange_4
//  624     {
//  625 //        CPlatform::InterruptDisable();
//  626 
//  627         uint8_t uiCounter = m_nuiBuffByteCounter;
//  628 
//  629 //        CPlatform::InterruptEnable();
//  630 
//  631         return uiCounter;
        LD      R16, Z
        RJMP    ??Exchange_5
//  632     }
//  633     else if (0 == m_nuiBuffByteCounter)
//  634     {
//  635         return 0;
//  636     }
//  637 
//  638     return 0;
??Exchange_4:
        LDI     R16, 0
??Exchange_5:
        LDI     R17, 0
??Exchange_3:
        RJMP    ?Subroutine24
//  639 }

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_nuiBuffByteCounter:
        DS8 2
??m_uiReceivedByteCounter:
        DS8 2
??m_uiExchangeByte:
        DS8 1
??m_bfByteIsReceived_1:
        DS8 1
??m_bfByteIsTransmited:
        DS8 1
??m_bfDataExchangeInProgress:
        DS8 1
??m_bfDataExchangeIsOccur:
        DS8 1
??m_bfRxBuffOverflow_1:
        DS8 1
//  640 
//  641 ////-----------------------------------------------------------------------------------------------------
//  642 //void CSpi::RecvInterruptHandler(void)
//  643 //{
//  644 ////    SPDR = m_uiExchangeByte;
//  645 ////    m_uiExchangeByte = SPDR;
//  646 ////    // буфер приёма не переполнен?
//  647 ////    if (m_nuiBuffByteCounter <
//  648 ////            SPI_MAX_BUFF_LENGTH)
//  649 ////    {
//  650 ////        m_nuiBuffByteCounter++;
//  651 ////        m_bfByteIsReceived = 1;
//  652 ////    }
//  653 ////    else
//  654 ////    {
//  655 ////        // не инкрементируем m_nuiBuffByteCounter, чтобы не выйти за границы буфера.
//  656 ////        // установим флаг - произошел обмен данными по SPI.
//  657 ////        m_bfRxBuffOverflow = 1;
//  658 ////        m_bfByteIsReceived = 1;
//  659 ////    }
//  660 //
//  661 //
//  662 ////    SPDR = m_uiExchangeByte;
//  663 ////    m_puiRxBuffer[m_nuiBuffByteCounter] = SPDR;
//  664 ////    m_uiExchangeByte = m_puiTxBuffer[m_nuiBuffByteCounter];
//  665 ////    // буфер приёма не переполнен?
//  666 ////    if (m_nuiBuffByteCounter <
//  667 ////            SPI_MAX_BUFF_LENGTH)
//  668 ////    {
//  669 ////        m_nuiBuffByteCounter++;
//  670 ////        m_bfByteIsReceived = 1;
//  671 ////    }
//  672 ////    else
//  673 ////    {
//  674 ////        // не инкрементируем m_nuiBuffByteCounter, чтобы не выйти за границы буфера.
//  675 ////        // установим флаг - произошел обмен данными по SPI.
//  676 ////        m_bfRxBuffOverflow = 1;
//  677 ////        m_bfByteIsReceived = 1;
//  678 ////    }
//  679 //}
//  680 
//  681 ////-----------------------------------------------------------------------------------------------------
//  682 //#pragma vector = SPI_STC_vect
//  683 //__interrupt void SIG_SPI_STC(void)
//  684 //{
//  685 //    SPDR = CSpi::m_uiExchangeByte;
//  686 //    CSpi::m_puiRxBuffer[CSpi::m_nuiBuffByteCounter] = SPDR;
//  687 //    CSpi::m_uiExchangeByte = CSpi::m_puiTxBuffer[CSpi::m_nuiBuffByteCounter + 1];
//  688 //
//  689 //    // буфер приёма не переполнен?
//  690 //    if (CSpi::m_nuiBuffByteCounter <
//  691 //            CSpi::BUFFER_LENGTH)
//  692 //    {
//  693 //        CSpi::m_nuiBuffByteCounter++;
//  694 //        CSpi::m_bfByteIsReceived = 1;
//  695 //    }
//  696 //    else
//  697 //    {
//  698 //        // не инкрементируем m_nuiBuffByteCounter, чтобы не выйти за границы буфера.
//  699 //        // установим флаг - произошел обмен данными по SPI.
//  700 //        CSpi::m_bfRxBuffOverflow = 1;
//  701 //        CSpi::m_bfByteIsReceived = 1;
//  702 //    }
//  703 //}
//  704 
//  705 //-----------------------------------------------------------------------------------------------------
//  706 
//  707 
//  708 
//  709 
//  710 
//  711 //-----------------------------------------------------------------------------------------------------
//  712 //// delay
//  713 //void delay_ms(uint16_t millisecs)
//  714 //{
//  715 //    while(millisecs--)
//  716 //    {
//  717 //        delay_us(1000);
//  718 //    }
//  719 //}
//  720 //void delay_s(uint16_t secs)
//  721 //{
//  722 //    while(secs--)
//  723 //    {
//  724 //        __delay_cycles(F_CPU);
//  725 //    }
//  726 //}
//  727 //void delay_mins(uint16_t minutes)
//  728 //{
//  729 //    while(minutes--)
//  730 //    {
//  731 //        __delay_cycles(60*F_CPU);
//  732 //    }
//  733 //}
//  734 
//  735 //-----------------------------------------------------------------------------------------------------
//  736 uint16_t CPlatform::m_uiSystemTick;
//  737 //CUart* CPlatform::m_pxUart0;
//  738 //CUart* CPlatform::m_pxUart1;
//  739 //CSpi* CPlatform::m_pxSpi;
//  740 uint8_t CPlatform::uiSlaveSelectIsHigh;
??uiSlaveSelectIsHigh:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_puiRxBuffer_1:
        DS8 2
??m_puiTxBuffer_1:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_auiSpiRxBuffer:
        DS8 16

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_auiSpiTxBuffer:
        DS8 16

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_uiSystemTick:
        DS8 2
//  741 
//  742 ////-----------------------------------------------------------------------------------------------------
//  743 //CPlatform::CPlatform()
//  744 //{
//  745 //
//  746 //}
//  747 //
//  748 ////-----------------------------------------------------------------------------------------------------
//  749 //CPlatform::~CPlatform()
//  750 //{
//  751 //
//  752 //}
//  753 
//  754 //-----------------------------------------------------------------------------------------------------
//  755 // INT0
//  756 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  757 void CPlatform::Int0InterruptEnable(void)
??Int0InterruptEnable:
//  758 {
//  759     // установим прерывание INT0 по переднему фронту(ожидание конца обмена данными по SPI).
//  760     EICRA &= ~(Bit(ISC01) | Bit(ISC00));
        RCALL   ?Subroutine13
//  761     EICRA |= (Bit(ISC01) | Bit(ISC00));
//  762     // разрешение внешнего прерывания INT0.
//  763     EIMSK |= Bit(INT0);
??CrossCallReturnLabel_14:
        SBI     0x1D, 0x00
//  764 }
        RET
        REQUIRE _A_EICRA
        REQUIRE _A_EIMSK
//  765 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  766 void CPlatform::Int0InterruptDisable(void)
??Int0InterruptDisable:
//  767 {
//  768     // запретим внешнее прерывание INT0.
//  769     EIMSK &= ~Bit(INT0);
        CBI     0x1D, 0x00
//  770 }
        RET
        REQUIRE _A_EIMSK
//  771 
//  772 //-----------------------------------------------------------------------------------------------------
//  773 #pragma vector = INT0_vect

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SIG_INT0, "interrupt"
//  774 __interrupt void SIG_INT0(void)
??SIG_INT0:
//  775 {
        ST      -Y, R17
        ST      -Y, R16
        IN      R17, 0x3F
//  776     // прерывание INT0 произошло по переднему фронту(закончен обмен данными по SPI)?
//  777     if (!(BIT_IS_SET(PIND, SPI_SS5)))
        LDI     R16, 1
        SBIC    0x09, 0x02
        RJMP    ??SIG_INT0_1
//  778     {
//  779         // прерывание INT0 произошло по переднему фронту(закончен обмен данными по SPI).
//  780         // установим флаг - вход SS0 переходил в 1(запущен демон ПАС).
//  781         CPlatform::uiSlaveSelectIsHigh = 1;
        STS     (??m_nuiBuffByteCounter + 10), R16
//  782         CSpi::DataExchangeInProgressClear();
        LDI     R16, 0
        STS     (??m_nuiBuffByteCounter + 7), R16
//  783         // запретим SPI.
//  784         CSpi::Disable();
        RCALL   ??Disable_1
//  785         // установим прерывание INT0 по переднему фронту(ожидание начала обмена данными по SPI).
//  786         EICRA &= ~(Bit(ISC01) | Bit(ISC00));
        RCALL   ?Subroutine13
//  787         EICRA |= (Bit(ISC01) | Bit(ISC00));
//  788         // установим флаг - произошел обмен данными по SPI.
//  789         CSpi::DataExchangeIsOccurSet();
??CrossCallReturnLabel_15:
        LDI     R16, 1
        STS     (??m_nuiBuffByteCounter + 8), R16
//  790         CMvsn21::FlowControlSet(CMvsn21::FSM_DATA_EXCHANGE_END);
        LDI     R16, 10
//  791         CPlatform::TxLedOff();
        CBI     0x0B, 0x03
//  792     }
        RJMP    ??SIG_INT0_2
//  793     else
//  794     {
//  795         CSpi::DataExchangeInProgressSet();
??SIG_INT0_1:
        STS     (??m_nuiBuffByteCounter + 7), R16
//  796         CSpi::Enable();
        RCALL   ??Enable_1
//  797         // установим прерывание INT0 по заднему фронту(ожидание конца обмена данными по SPI).
//  798         EICRA &= ~(Bit(ISC01) | Bit(ISC00));
        RCALL   ?Subroutine14
//  799         EICRA |= (Bit(ISC01));
??CrossCallReturnLabel_16:
        LDS     R16, 105
        ORI     R16, 0x02
        STS     105, R16
//  800         CMvsn21::FlowControlSet(CMvsn21::FSM_START);
        LDI     R16, 1
//  801         CMvsn21::MeasureFlowControlSet(CMvsn21::FSM_START);
        STS     ??m_uiMeasureFlowControl, R16
//  802         CPlatform::TxLedOn();
        SBI     0x0B, 0x03
//  803     }
??SIG_INT0_2:
        STS     ??m_uiFlowControl, R16
//  804 }
        OUT     0x3F, R17
        LD      R16, Y+
        LD      R17, Y+
        RETI
        REQUIRE _A_PIND
        REQUIRE _A_EICRA
        REQUIRE _A_PORTD

        RSEG CODE:CODE:NOROOT(1)
?Subroutine13:
        RCALL   ?Subroutine14
??CrossCallReturnLabel_17:
        LDS     R16, _A_EICRA
        ORI     R16, 0x03
        REQUIRE ?Subroutine16
        ;               // Fall through to label ?Subroutine16

        RSEG CODE:CODE:NOROOT(1)
?Subroutine16:
        STS     _A_EICRA, R16
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine14:
        LDS     R16, _A_EICRA
        ANDI    R16, 0xFC
        RJMP    ?Subroutine16
//  805 
//  806 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  807 void SystemTickInit(void)
??SystemTickInit:
//  808 {
//  809 #define MAIN_TIMER_TICK_RATE_HZ 1000
//  810 
//  811 //#define TIMER1_INTERRUPT
//  812 #define TIMER2_INTERRUPT
//  813 
//  814 
//  815 #ifdef TIMER2_INTERRUPT
//  816     /* Hardware constants for timer 2. */
//  817 #define portCLEAR_COUNTER_ON_MATCH              ( ( unsigned char ) _BV(WGM21) )
//  818 #define portPRESCALE_64                         ( ( unsigned char ) (_BV(CS21) | _BV(CS20)) )
//  819 #define portCLOCK_PRESCALER                     ( ( unsigned long ) 64 )
//  820 #define portCOMPARE_MATCH_A_INTERRUPT_ENABLE    ( ( unsigned char ) _BV(OCIE2A) )
//  821 #endif //TIMER2_INTERRUPT
//  822 
//  823 #ifdef TIMER1_INTERRUPT
//  824     /* Hardware constants for timer 1. */
//  825 #define portCLEAR_COUNTER_ON_MATCH              ( ( unsigned char ) _BV(WGM12) )
//  826 #define portPRESCALE_64                         ( ( unsigned char ) (_BV(CS11) | _BV(CS10)) )
//  827 #define portCLOCK_PRESCALER                     ( ( unsigned long ) 64 )
//  828 #define portCOMPARE_MATCH_A_INTERRUPT_ENABLE    ( ( unsigned char ) _BV(OCIE1A) )
//  829 #endif //TIMER1_INTERRUPT
//  830 
//  831 #ifdef TIMER2_INTERRUPT
//  832 
//  833     OCR2A = (((F_CPU / MAIN_TIMER_TICK_RATE_HZ) / 128) - 1);
        LDI     R16, 114
        STS     _A_OCR2A, R16
//  834     TCCR2A |= (Bit(WGM21));
        LDS     R16, 176
        ORI     R16, 0x02
        STS     176, R16
//  835     TCCR2B |= (Bit(CS22) | Bit(CS20));
        LDS     R16, _A_TCCR2B
        ORI     R16, 0x05
        STS     _A_TCCR2B, R16
//  836 
//  837     TIMSK2 |= Bit(OCIE2A);
        LDS     R16, 112
        ORI     R16, 0x02
        STS     112, R16
//  838 
//  839 #endif //TIMER2_INTERRUPT
//  840 
//  841 #ifdef TIMER1_INTERRUPT
//  842 //
//  843 //    unsigned long ulCompareMatch;
//  844 //    unsigned char ucLowByte;
//  845 //
//  846 //    /* Using 16bit timer 1 to generate the tick.  Correct fuses must be
//  847 //    selected for the configCPU_CLOCK_HZ clock. */
//  848 //
//  849 //    ulCompareMatch = CPlatform::F_CPU / MAIN_TIMER_TICK_RATE_HZ;
//  850 //
//  851 //    /* We only have 16 bits so have to scale to get our required tick rate. */
//  852 //    ulCompareMatch /= portCLOCK_PRESCALER;
//  853 //
//  854 //    /* Adjust for correct value. */
//  855 //    ulCompareMatch -= ( unsigned long ) 1;
//  856 //
//  857 //    /* Setup compare match value for compare match A.  Interrupts are disabled
//  858 //    before this is called so we need not worry here. */
//  859 //    OCR1A = ulCompareMatch;
//  860 //
//  861 //    /* Setup clock source and compare match behaviour. */
//  862 //    TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));
//  863 //    ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
//  864 //    TCCR1B = ucLowByte;
//  865 //
//  866 //    /* Enable the interrupt - this is okay as interrupt are currently globally
//  867 //    disabled. */
//  868 //    ucLowByte = TIMSK;
//  869 //    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
//  870 //    TIMSK = ucLowByte;
//  871 
//  872 #endif //TIMER1_INTERRUPT
//  873 
//  874 }
        RET
        REQUIRE _A_OCR2A
        REQUIRE _A_TCCR2A
        REQUIRE _A_TCCR2B
        REQUIRE _A_TIMSK2
//  875 
//  876 ////-----------------------------------------------------------------------------------------------------
//  877 //#ifdef TIMER1_INTERRUPT
//  878 //// Прерывание TIMER1_COMPA_vect
//  879 //__interrupt void SystemTickInterrupt(void)
//  880 //{
//  881 //    CPlatform::IncrementSystemTick();
//  882 //}
//  883 //#endif //TIMER1_INTERRUPT
//  884 //-----------------------------------------------------------------------------------------------------
//  885 #ifdef TIMER2_INTERRUPT
//  886 // Прерывание TIMER2_COMP_vect
//  887 #pragma vector = TIMER2_COMPA_vect	// Прерывание по совпадению TMR2 с OCR2

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SystemTickInterrupt, "interrupt"
//  888 __interrupt void SystemTickInterrupt(void)
??SystemTickInterrupt:
//  889 {
        RCALL   ?Subroutine11
//  890     CPlatform::IncrementSystemTick();
??CrossCallReturnLabel_10:
        LDI     R30, LOW(??m_uiSystemTick)
        LDI     R31, (??m_uiSystemTick) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        SUBI    R16, 255
        SBCI    R17, 255
        ST      Z, R16
        STD     Z+1, R17
//  891 }
        RCALL   ?Subroutine12
??CrossCallReturnLabel_12:
        RETI

        RSEG CODE:CODE:NOROOT(1)
?Subroutine12:
        OUT     0x3F, R18
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R30, Y+
        LD      R31, Y+
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine11:
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R18, 0x3F
        RET
//  892 #endif //TIMER2_INTERRUPT
//  893 
//  894 
//  895 
//  896 
//  897 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  898 void CPlatform::Init(void)
??Init_3:
//  899 {
//  900     SystemTickInit();
        RCALL   ??SystemTickInit
//  901     TxLedSetPinOutput();
        SBI     0x0A, 0x03
//  902 }
        RET
        REQUIRE _A_DDRD

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        COMMON INTVEC:CODE:ROOT(1)
        ORG 2
`??SIG_INT0::??INTVEC 2`:
        RJMP    ??SIG_INT0

        COMMON INTVEC:CODE:ROOT(1)
        ORG 14
`??SystemTickInterrupt::??INTVEC 14`:
        RJMP    ??SystemTickInterrupt

        COMMON INTVEC:CODE:ROOT(1)
        ORG 36
`??SIG_UART0_RECV::??INTVEC 36`:
        RJMP    ??SIG_UART0_RECV

        COMMON INTVEC:CODE:ROOT(1)
        ORG 38
`??SIG_UART0_DATA::??INTVEC 38`:
        RJMP    ??SIG_UART0_DATA

        COMMON INTVEC:CODE:ROOT(1)
        ORG 40
`??SIG_UART0_TXC::??INTVEC 40`:
        RJMP    ??SIG_UART0_TXC

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        RSEG NEAR_F:CODE:ROOT(0)
// __vtbl_entry const __flash CSpi::__vtbl[1]
??__vtbl:
        DC16 `?~CSpi`/2

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0

        END
// 
//    87 bytes in segment ABSOLUTE
// 1 244 bytes in segment CODE
//     6 bytes in segment INITTAB
//    10 bytes in segment INTVEC
//     4 bytes in segment NEAR_F
//    95 bytes in segment NEAR_Z
// 
// 1 246 bytes of CODE memory (+ 18 bytes shared)
//    95 bytes of DATA memory (+ 87 bytes shared)
//
//Errors: none
//Warnings: 4
