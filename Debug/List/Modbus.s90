///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR          12/May/2022  12:49:03
// Copyright 1996-2018 IAR Systems AB.
//
//    Source file  =  D:\Projects\CautoProjects\Mvsn21\Mvsn21\Modbus\Modbus.cpp
//    Command line =  
//        -f C:\Users\ghost\AppData\Local\Temp\EW71C9.tmp
//        (--string_literals_in_flash
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\Modbus\Modbus.cpp --cpu=m48
//        -ms -o D:\Projects\CautoProjects\Mvsn21\Mvsn21\Debug\Obj -lB
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\Debug\List
//        --initializers_in_flash --root_variables --debug
//        -DENABLE_BIT_DEFINITIONS -e -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\include\ -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\Modbus\ --eeprom_size 256
//        --dlib --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 8.0\avr\LIB\DLIB\dlAVR-1s-ec_mul-n.h" -Ohz --eec++)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21\Debug\List\Modbus.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME Modbus

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?EPILOGUE_B10_L09
        EXTERN ?EPILOGUE_B2_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B5_L09
        EXTERN ?PROLOGUE10_L09
        EXTERN ?PROLOGUE2_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE5_L09
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?S_SHL_L02
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC ??ByteToBitPack
        PUBLIC ??MessengerIsReady
        PUBLIC ??ReadDiscreteInputsReceive
        PUBLIC ??ReadDiscreteInputsRequest
        PUBLIC ??ReceiveMessage
        PUBLIC ??SendMessage
        PUBLIC ??SlaveSet
        PUBLIC ??m_puiDiscreteInputs
        PUBLIC ??m_puiRxBuffer
        PUBLIC ??m_puiTxBuffer
        PUBLIC ??m_uiDiscreteInputsNumber
        PUBLIC ??m_uiFlowControl
        PUBLIC ??m_uiFunctionCode
        PUBLIC ??m_uiLastSystemTime
        PUBLIC ??m_uiMessageLength
        PUBLIC ??m_uiOwnAddress
        PUBLIC ??m_uiQuantity
        PUBLIC ??m_uiSlaveAddress
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADCSRB
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_CLKPR
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_DIDR0
        PUBWEAK _A_DIDR1
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_EICRA
        PUBWEAK _A_EIFR
        PUBWEAK _A_EIMSK
        PUBWEAK _A_GPIOR0
        PUBWEAK _A_GPIOR1
        PUBWEAK _A_GPIOR2
        PUBWEAK _A_GTCCR
        PUBWEAK _A_ICR1
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUSR
        PUBWEAK _A_OCR0A
        PUBWEAK _A_OCR0B
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR2A
        PUBWEAK _A_OCR2B
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PCICR
        PUBWEAK _A_PCIFR
        PUBWEAK _A_PCMSK0
        PUBWEAK _A_PCMSK1
        PUBWEAK _A_PCMSK2
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_PRR
        PUBWEAK _A_SMCR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0A
        PUBWEAK _A_TCCR0B
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR1C
        PUBWEAK _A_TCCR2A
        PUBWEAK _A_TCCR2B
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TIFR0
        PUBWEAK _A_TIFR1
        PUBWEAK _A_TIFR2
        PUBWEAK _A_TIMSK0
        PUBWEAK _A_TIMSK1
        PUBWEAK _A_TIMSK2
        PUBWEAK _A_TWAMR
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRR0
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UCSR0C
        PUBWEAK _A_UDR0
        PUBWEAK _A_WDTCSR
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

`?<Name CModbus 1>` SYMBOL "CModbus"
`?<Name CMvsn21 12>` SYMBOL "CMvsn21"
??axChipsChannelsData SYMBOL "axChipsChannelsData", `?<Name CMvsn21 12>`
??m_puiDiscreteInputs SYMBOL "m_puiDiscreteInputs", `?<Name CModbus 1>`
??m_puiRxBuffer     SYMBOL "m_puiRxBuffer", `?<Name CModbus 1>`
??m_puiTxBuffer     SYMBOL "m_puiTxBuffer", `?<Name CModbus 1>`
??m_uiDiscreteInputsNumber SYMBOL "m_uiDiscreteInputsNumber", `?<Name CModbus 1>`
??m_uiFlowControl   SYMBOL "m_uiFlowControl", `?<Name CModbus 1>`
??m_uiFunctionCode  SYMBOL "m_uiFunctionCode", `?<Name CModbus 1>`
??m_uiLastSystemTime SYMBOL "m_uiLastSystemTime", `?<Name CModbus 1>`
??m_uiMessageLength SYMBOL "m_uiMessageLength", `?<Name CModbus 1>`
??m_uiOwnAddress    SYMBOL "m_uiOwnAddress", `?<Name CModbus 1>`
??m_uiQuantity      SYMBOL "m_uiQuantity", `?<Name CModbus 1>`
??m_uiSlaveAddress  SYMBOL "m_uiSlaveAddress", `?<Name CModbus 1>`

        EXTERN ??RequestBasis
        EXTERN ??Send
        EXTERN ??Tail
        EXTERN ??axChipsChannelsData

// D:\Projects\CautoProjects\Mvsn21\Mvsn21\Modbus\Modbus.cpp
//    1 //-----------------------------------------------------------------------------------------------------
//    2 //  Sourse      : FileName.cpp
//    3 //  Created     : 01.06.2022
//    4 //  Author      : Alexandr Volvenkin
//    5 //  email       : aav-36@mail.ru
//    6 //  GitHub      : https://github.com/AlexandrVolvenkin
//    7 //-----------------------------------------------------------------------------------------------------
//    8 
//    9 #include "Modbus.h"

        ASEGN ABSOLUTE:DATA:ROOT,0c6H
// union <unnamed> volatile __io _A_UDR0
_A_UDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c4H
// union <unnamed> volatile __io _A_UBRR0
_A_UBRR0:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,0c2H
// union <unnamed> volatile __io _A_UCSR0C
_A_UCSR0C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c1H
// union <unnamed> volatile __io _A_UCSR0B
_A_UCSR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c0H
// union <unnamed> volatile __io _A_UCSR0A
_A_UCSR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bdH
// union <unnamed> volatile __io _A_TWAMR
_A_TWAMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bcH
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bbH
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0baH
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b9H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b8H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b6H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b4H
// union <unnamed> volatile __io _A_OCR2B
_A_OCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b3H
// union <unnamed> volatile __io _A_OCR2A
_A_OCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b2H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b1H
// union <unnamed> volatile __io _A_TCCR2B
_A_TCCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b0H
// union <unnamed> volatile __io _A_TCCR2A
_A_TCCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08aH
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,088H
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,086H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,084H
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,082H
// union <unnamed> volatile __io _A_TCCR1C
_A_TCCR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,081H
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,080H
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07fH
// union <unnamed> volatile __io _A_DIDR1
_A_DIDR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07eH
// union <unnamed> volatile __io _A_DIDR0
_A_DIDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07cH
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07bH
// union <unnamed> volatile __io _A_ADCSRB
_A_ADCSRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07aH
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,078H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,070H
// union <unnamed> volatile __io _A_TIMSK2
_A_TIMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06fH
// union <unnamed> volatile __io _A_TIMSK1
_A_TIMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06eH
// union <unnamed> volatile __io _A_TIMSK0
_A_TIMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06dH
// union <unnamed> volatile __io _A_PCMSK2
_A_PCMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06cH
// union <unnamed> volatile __io _A_PCMSK1
_A_PCMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06bH
// union <unnamed> volatile __io _A_PCMSK0
_A_PCMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,069H
// union <unnamed> volatile __io _A_EICRA
_A_EICRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,068H
// union <unnamed> volatile __io _A_PCICR
_A_PCICR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,066H
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,064H
// union <unnamed> volatile __io _A_PRR
_A_PRR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,061H
// union <unnamed> volatile __io _A_CLKPR
_A_CLKPR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,060H
// union <unnamed> volatile __io _A_WDTCSR
_A_WDTCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUSR
_A_MCUSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_SMCR
_A_SMCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04dH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04bH
// union <unnamed> volatile __io _A_GPIOR2
_A_GPIOR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_GPIOR1
_A_GPIOR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR0B
_A_OCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,047H
// union <unnamed> volatile __io _A_OCR0A
_A_OCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR0B
_A_TCCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCCR0A
_A_TCCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_GTCCR
_A_GTCCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03fH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_GPIOR0
_A_GPIOR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EIMSK
_A_EIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EIFR
_A_EIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PCIFR
_A_PCIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_TIFR2
_A_TIFR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_TIFR1
_A_TIFR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_TIFR0
_A_TIFR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,025H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS8 1
//   10 #include "ModbusRTU.h"
//   11 #include "Platform.h"
//   12 #include "Mvsn21.h"
//   13 
//   14 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   15 uint8_t CModbus::m_uiOwnAddress;
??m_uiOwnAddress:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   16 uint8_t CModbus::m_uiSlaveAddress;
//   17 uint8_t CModbus::m_uiFunctionCode;
//   18 uint16_t CModbus::m_uiQuantity;
??m_uiQuantity:
        DS8 2
//   19 uint8_t CModbus::m_uiFlowControl;
//   20 //    CSocket* pxSocket;
//   21 uint16_t CModbus::m_uiLastSystemTime;
//   22 uint16_t CModbus::m_uiMessageLength;
??m_uiMessageLength:
        DS8 2
//   23 uint8_t *CModbus::m_puiRxBuffer;
//   24 uint8_t *CModbus::m_puiTxBuffer;
??m_puiTxBuffer:
        DS8 2
??m_uiSlaveAddress:
        DS8 1
??m_uiFunctionCode:
        DS8 1
??m_uiFlowControl:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_uiLastSystemTime:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
??m_puiRxBuffer:
        DS8 2
//   25 //uint8_t *CModbus::m_puiCoils;

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   26 uint8_t *CModbus::m_puiDiscreteInputs;
??m_puiDiscreteInputs:
        DS8 2
//   27 //uint16_t *CModbus::m_pui16HoldingRegisters;
//   28 //uint16_t *CModbus::m_pui16InputRegisters;
//   29 //uint16_t CModbus::m_uiCoilsNumber;

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   30 uint16_t CModbus::m_uiDiscreteInputsNumber;
??m_uiDiscreteInputsNumber:
        DS8 2
//   31 //uint16_t CModbus::m_uiHoldingRegistersNumber;
//   32 //uint16_t CModbus::m_uiInputRegistersNumber;
//   33 
//   34 ////-----------------------------------------------------------------------------------------------------
//   35 //CModbus::CModbus()
//   36 //{
//   37 //    //ctor
//   38 //}
//   39 //
//   40 //////-----------------------------------------------------------------------------------------------------
//   41 ////CModbus::CModbus(CUart* pxDevice,
//   42 ////                 uint32_t uiBaudRate,
//   43 ////                 char cParity,
//   44 ////                 uint8_t uiDataBit,
//   45 ////                 uint8_t uiStopBit,
//   46 ////                 uint8_t *puiRxBuffer,
//   47 ////                 uint8_t *puiTxBuffer) :
//   48 ////    pxDevice(pxDevice),
//   49 ////    uiBaudRate(uiBaudRate),
//   50 ////    cParity(cParity),
//   51 ////    uiDataBit(uiDataBit),
//   52 ////    uiStopBit(uiStopBit),
//   53 ////    m_puiRxBuffer(puiRxBuffer),
//   54 ////    m_puiTxBuffer(puiTxBuffer)
//   55 ////{
//   56 ////    m_uiFlowControl = MODBUS_IDDLE;
//   57 ////}
//   58 //
//   59 ////-----------------------------------------------------------------------------------------------------
//   60 //CModbus::~CModbus()
//   61 //{
//   62 //
//   63 //}
//   64 
//   65 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   66 void CModbus::SlaveSet(uint8_t uiSlave)
??SlaveSet:
//   67 {
//   68     m_uiOwnAddress = uiSlave;
        STS     ??m_uiOwnAddress, R16
//   69 }
        RET
//   70 
//   71 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   72 int8_t CModbus::MessengerIsReady(void)
??MessengerIsReady:
//   73 {
//   74     uint8_t uiData;
//   75     if (m_uiFlowControl == IDDLE)
        LDS     R16, (??m_uiQuantity + 8)
        TST     R16
        BRNE    ??MessengerIsReady_1
//   76     {
//   77         return 1;
        LDI     R16, 1
        RET
//   78     }
//   79     else
//   80     {
//   81         return 0;
??MessengerIsReady_1:
        LDI     R16, 0
        RET
//   82     }
//   83 }
//   84 
//   85 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   86 int16_t CModbus::SendMessage(uint8_t *puiMessage, uint16_t uiLength)
??SendMessage:
//   87 {
        RCALL   ?PROLOGUE2_L09
        MOVW    R25:R24, R17:R16
//   88     uiLength = CModbusRTU::Tail(puiMessage, uiLength);
        RCALL   ??Tail
//   89     return CModbusRTU::Send(puiMessage, uiLength);
        MOVW    R19:R18, R17:R16
        MOVW    R17:R16, R25:R24
        RCALL   ??Send
        LDI     R30, 2
        RJMP    ?EPILOGUE_B2_L09
//   90 }
//   91 
//   92 ////-----------------------------------------------------------------------------------------------------
//   93 ///* Build the exception response */
//   94 //int16_t CModbus::ResponseException(uint8_t uiSlave, uint8_t uiFunctionCode, uint8_t uiExceptionCode, uint8_t *puiResponse)
//   95 //{
//   96 //    int16_t uiLength;
//   97 //
//   98 //    uiLength = CModbusRTU::ResponseBasis(uiSlave, (uiFunctionCode | 0x80), puiResponse);
//   99 //    /* Positive exception code */
//  100 //    puiResponse[uiLength++] = uiExceptionCode;
//  101 //
//  102 //    return uiLength;
//  103 //}
//  104 
//  105 ////-----------------------------------------------------------------------------------------------------
//  106 //uint8_t CModbus::ResponseIsReceived(void)
//  107 //{
//  108 //    if (m_uiFlowControl == IDDLE)
//  109 //    {
//  110 //        return 1;
//  111 //    }
//  112 //    else
//  113 //    {
//  114 //        return 0;
//  115 //    }
//  116 //};
//  117 
//  118 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  119 int16_t CModbus::ByteToBitPack(uint16_t uiAddress,
??ByteToBitPack:
//  120                                uint16_t uiNumberB,
//  121                                uint8_t *m_puiCoils,
//  122                                uint8_t *puiResponse,
//  123                                uint16_t uiLength)
//  124 {
        RCALL   ?PROLOGUE10_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        MOVW    R5:R4, R17:R16
        MOVW    R1:R0, R19:R18
        MOVW    R3:R2, R21:R20
//  125     uint8_t uiData = 0;
        LDI     R21, 0
//  126     uint8_t uiShift = 0;
        CLR     R6
//  127     for (uint16_t i = 0; i < uiNumberB; i++)
        LDI     R18, 0
        LDI     R19, 0
        LDD     R24, Y+10
        LDD     R25, Y+11
        RJMP    ??ByteToBitPack_1
//  128     {
//  129         if (m_puiCoils[uiAddress++])
//  130         {
//  131             uiData |= (1 << uiShift);
//  132         }
//  133         // Byte is full?
//  134         if (uiShift == 7)
//  135         {
//  136             puiResponse[uiLength++] = uiData;
//  137             uiData = 0;
//  138             uiShift = 0;
//  139         }
//  140         else
//  141         {
//  142             uiShift++;
??ByteToBitPack_2:
        INC     R6
//  143         }
??ByteToBitPack_3:
        SUBI    R18, 255
        SBCI    R19, 255
??ByteToBitPack_1:
        MOVW    R31:R30, R23:R22
        ADD     R30, R24
        ADC     R31, R25
        CP      R18, R0
        CPC     R19, R1
        BRCC    ??ByteToBitPack_4
        MOVW    R9:R8, R5:R4
        LDI     R16, 1
        ADD     R4, R16
        LDI     R16, 0
        ADC     R5, R16
        MOVW    R27:R26, R3:R2
        ADD     R26, R8
        ADC     R27, R9
        LD      R16, X
        TST     R16
        BREQ    ??ByteToBitPack_5
        RCALL   ?Subroutine1
??CrossCallReturnLabel_3:
        MOV     R20, R6
        RCALL   ?S_SHL_L02
        OR      R21, R16
??ByteToBitPack_5:
        LDI     R16, 7
        CP      R6, R16
        BRNE    ??ByteToBitPack_2
        ST      Z, R21
        ADIW    R25:R24, 1
        LDI     R21, 0
        CLR     R6
        RJMP    ??ByteToBitPack_3
//  144     }
//  145 
//  146     if (uiShift != 0)
??ByteToBitPack_4:
        TST     R6
        BREQ    ??ByteToBitPack_6
//  147     {
//  148         puiResponse[uiLength++] = uiData;
        ST      Z, R21
        ADIW    R25:R24, 1
//  149     }
//  150 
//  151     return uiLength;
??ByteToBitPack_6:
        MOVW    R17:R16, R25:R24
        LDI     R30, 12
        RJMP    ?EPILOGUE_B10_L09
//  152 }
//  153 
//  154 ////-----------------------------------------------------------------------------------------------------
//  155 //int16_t CModbus::ReadCoils(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  156 //{
//  157 //    uint16_t uiOffset = HEADER_LENGTH;
//  158 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  159 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  160 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  161 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  162 //
//  163 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  164 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  165 //
//  166 //    if (uiNumberB < 1 || MODBUS_MAX_READ_BITS < uiNumberB)
//  167 //    {
//  168 //        uiLength = ResponseException(uiSlave,
//  169 //                                     uiFunctionCode,
//  170 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  171 //                                     puiResponse);
//  172 //    }
//  173 //    else if ((uiAddress + uiNumberB) > m_uiCoilsNumber)
//  174 //    {
//  175 //        uiLength = ResponseException(uiSlave,
//  176 //                                     uiFunctionCode,
//  177 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  178 //                                     puiResponse);
//  179 //    }
//  180 //    else
//  181 //    {
//  182 //        uiLength = CModbusRTU::ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  183 //
//  184 //        if (uiNumberB % 8)
//  185 //        {
//  186 //            puiResponse[uiLength++] = ((uiNumberB / 8) + 1);
//  187 //        }
//  188 //        else
//  189 //        {
//  190 //            puiResponse[uiLength++] = (uiNumberB / 8);
//  191 //        }
//  192 //        uiLength = ByteToBitPack(uiAddress,
//  193 //                                 uiNumberB,
//  194 //                                 m_puiCoils,
//  195 //                                 puiResponse,
//  196 //                                 uiLength);
//  197 //    }
//  198 //    return uiLength;
//  199 //}
//  200 
//  201 ////-----------------------------------------------------------------------------------------------------
//  202 //int16_t CModbus::ReadDiscreteInputs(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  203 //{
//  204 //    uint16_t uiOffset = HEADER_LENGTH;
//  205 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  206 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  207 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  208 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  209 //
//  210 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  211 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  212 //
//  213 //    if (uiNumberB < 1 || MODBUS_MAX_READ_BITS < uiNumberB)
//  214 //    {
//  215 //        uiLength = ResponseException(uiSlave,
//  216 //                                     uiFunctionCode,
//  217 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  218 //                                     puiResponse);
//  219 //    }
//  220 //    else if ((uiAddress + uiNumberB) > m_uiDiscreteInputsNumber)
//  221 //    {
//  222 //        uiLength = ResponseException(uiSlave,
//  223 //                                     uiFunctionCode,
//  224 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  225 //                                     puiResponse);
//  226 //    }
//  227 //    else
//  228 //    {
//  229 //        uiLength = CModbusRTU::ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  230 //
//  231 //        if (uiNumberB % 8)
//  232 //        {
//  233 //            puiResponse[uiLength++] = ((uiNumberB / 8) + 1);
//  234 //        }
//  235 //        else
//  236 //        {
//  237 //            puiResponse[uiLength++] = (uiNumberB / 8);
//  238 //        }
//  239 //        uiLength = ByteToBitPack(uiAddress,
//  240 //                                 uiNumberB,
//  241 //                                 m_puiDiscreteInputs,
//  242 //                                 puiResponse,
//  243 //                                 uiLength);
//  244 //    }
//  245 //    return uiLength;
//  246 //}
//  247 
//  248 ////-----------------------------------------------------------------------------------------------------
//  249 //int16_t CModbus::ReadHoldingRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  250 //{
//  251 //    uint16_t uiOffset = HEADER_LENGTH;
//  252 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  253 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  254 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  255 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  256 //
//  257 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  258 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  259 //
//  260 //    if (uiNumberB < 1 || MODBUS_MAX_READ_REGISTERS < uiNumberB)
//  261 //    {
//  262 //        uiLength = ResponseException(uiSlave,
//  263 //                                     uiFunctionCode,
//  264 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  265 //                                     puiResponse);
//  266 //    }
//  267 //    else if ((uiAddress + uiNumberB) > m_uiHoldingRegistersNumber)
//  268 //    {
//  269 //        uiLength = ResponseException(uiSlave,
//  270 //                                     uiFunctionCode,
//  271 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  272 //                                     puiResponse);
//  273 //    }
//  274 //    else
//  275 //    {
//  276 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  277 //        puiResponse[uiLength++] = (uiNumberB << 1);
//  278 //        for (uint16_t i = 0; i < uiNumberB; i++)
//  279 //        {
//  280 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16HoldingRegisters[uiAddress]) >> 8);
//  281 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16HoldingRegisters[uiAddress++]) & 0x00FF);
//  282 //        }
//  283 //    }
//  284 //    return uiLength;
//  285 //}
//  286 //
//  287 ////-----------------------------------------------------------------------------------------------------
//  288 //int16_t CModbus::ReadInputRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  289 //{
//  290 //    uint16_t uiOffset = HEADER_LENGTH;
//  291 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  292 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  293 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  294 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  295 //
//  296 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  297 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  298 //
//  299 //    if (uiNumberB < 1 || MODBUS_MAX_READ_REGISTERS < uiNumberB)
//  300 //    {
//  301 //        uiLength = ResponseException(uiSlave,
//  302 //                                     uiFunctionCode,
//  303 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  304 //                                     puiResponse);
//  305 //    }
//  306 //    else if ((uiAddress + uiNumberB) > m_uiInputRegistersNumber)
//  307 //    {
//  308 //        uiLength = ResponseException(uiSlave,
//  309 //                                     uiFunctionCode,
//  310 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  311 //                                     puiResponse);
//  312 //    }
//  313 //    else
//  314 //    {
//  315 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  316 //        puiResponse[uiLength++] = (uiNumberB << 1);
//  317 //        for (uint16_t i = 0; i < uiNumberB; i++)
//  318 //        {
//  319 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16InputRegisters[uiAddress]) >> 8);
//  320 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16InputRegisters[uiAddress++]) & 0x00FF);
//  321 //        }
//  322 //    }
//  323 //    return uiLength;
//  324 //}
//  325 
//  326 ////-----------------------------------------------------------------------------------------------------
//  327 //int16_t CModbus::WriteSingleCoil(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  328 //{
//  329 //    uint16_t uiOffset = HEADER_LENGTH;
//  330 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  331 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  332 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  333 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  334 //
//  335 //    if (uiAddress >= m_uiCoilsNumber)
//  336 //    {
//  337 //        uiLength = ResponseException(uiSlave,
//  338 //                                     uiFunctionCode,
//  339 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  340 //                                     puiResponse);
//  341 //    }
//  342 //    else
//  343 //    {
//  344 //        uint16_t uiData = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  345 //                           (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  346 //
//  347 //        if (uiData == 0xFF00 || uiData == 0x0)
//  348 //        {
//  349 //            if (uiData)
//  350 //            {
//  351 //                m_puiCoils[uiAddress] = ON;
//  352 //            }
//  353 //            else
//  354 //            {
//  355 //                m_puiCoils[uiAddress] = OFF;
//  356 //            }
//  357 //            memcpy(puiResponse, puiRequest, uiLength);
//  358 //        }
//  359 //        else
//  360 //        {
//  361 //            uiLength = ResponseException(uiSlave,
//  362 //                                         uiFunctionCode,
//  363 //                                         MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  364 //                                         puiResponse);
//  365 //        }
//  366 //    }
//  367 //    return uiLength;
//  368 //}
//  369 //
//  370 ////-----------------------------------------------------------------------------------------------------
//  371 //int16_t CModbus::WriteSingleRegister(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  372 //{
//  373 //    uint16_t uiOffset = HEADER_LENGTH;
//  374 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  375 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  376 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  377 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  378 //
//  379 //    if (uiAddress >= m_uiHoldingRegistersNumber)
//  380 //    {
//  381 //        uiLength = ResponseException(uiSlave,
//  382 //                                     uiFunctionCode,
//  383 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  384 //                                     puiResponse);
//  385 //    }
//  386 //    else
//  387 //    {
//  388 //        m_pui16HoldingRegisters[uiAddress] =
//  389 //            ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  390 //             (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  391 //        memcpy(puiResponse, puiRequest, uiLength);
//  392 //    }
//  393 //    return uiLength;
//  394 //}
//  395 //
//  396 ////-----------------------------------------------------------------------------------------------------
//  397 //int16_t CModbus::WriteMultipleCoils(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  398 //{
//  399 //    uint16_t uiOffset = HEADER_LENGTH;
//  400 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  401 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  402 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  403 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  404 //
//  405 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  406 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  407 //
//  408 //    if (uiNumberB < 1 || MODBUS_MAX_WRITE_BITS < uiNumberB)
//  409 //    {
//  410 //        uiLength = ResponseException(uiSlave,
//  411 //                                     uiFunctionCode,
//  412 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  413 //                                     puiResponse);
//  414 //    }
//  415 //    else if ((uiAddress + uiNumberB) > m_uiCoilsNumber)
//  416 //    {
//  417 //        uiLength = ResponseException(uiSlave,
//  418 //                                     uiFunctionCode,
//  419 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  420 //                                     puiResponse);
//  421 //    }
//  422 //    else
//  423 //    {
//  424 //
//  425 //        SetBytesFromBits(m_puiCoils, uiAddress, uiNumberB, &puiRequest[uiOffset + 6]);
//  426 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  427 //        /* 4 to copy the bit address (2) and the quantity of bits */
//  428 //        memcpy(puiResponse + uiLength, puiRequest + uiLength, 4);
//  429 //        uiLength += 4;
//  430 //    }
//  431 //    return uiLength;
//  432 //}
//  433 //
//  434 ////-----------------------------------------------------------------------------------------------------
//  435 //int16_t CModbus::WriteMultipleRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  436 //{
//  437 //    uint16_t uiOffset = HEADER_LENGTH;
//  438 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  439 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  440 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  441 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  442 //
//  443 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  444 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  445 //
//  446 //    if (uiNumberB < 1 || MODBUS_MAX_WRITE_REGISTERS < uiNumberB)
//  447 //    {
//  448 //        uiLength = ResponseException(uiSlave,
//  449 //                                     uiFunctionCode,
//  450 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  451 //                                     puiResponse);
//  452 //    }
//  453 //    else if ((uiAddress + uiNumberB) > m_uiHoldingRegistersNumber)
//  454 //    {
//  455 //        uiLength = ResponseException(uiSlave,
//  456 //                                     uiFunctionCode,
//  457 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  458 //                                     puiResponse);
//  459 //    }
//  460 //    else
//  461 //    {
//  462 //        for (uint16_t i = 0; i < uiNumberB; i++)
//  463 //        {
//  464 //            m_pui16HoldingRegisters[uiAddress++] = ((static_cast<uint16_t>(puiRequest[uiOffset + 6]) << 8) |
//  465 //                                                    (static_cast<uint16_t>(puiRequest[uiOffset + 6 + 1])));
//  466 //            uiOffset += 2;
//  467 //        }
//  468 //
//  469 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  470 //        /* 4 to copy the bit address (2) and the quantity of bits */
//  471 //        memcpy(puiResponse + uiLength, puiRequest + uiLength, 4);
//  472 //        uiLength += 4;
//  473 //
//  474 //    }
//  475 //    return uiLength;
//  476 //}
//  477 
//  478 ////-----------------------------------------------------------------------------------------------------
//  479 //int16_t CModbus::ReadExceptionStatus(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  480 //{
//  481 ////    errno = ENOPROTOOPT;
//  482 //    return -1;
//  483 //}
//  484 //
//  485 ////-----------------------------------------------------------------------------------------------------
//  486 //int16_t CModbus::WriteAndReadRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  487 //{
//  488 //}
//  489 //
//  490 ////-----------------------------------------------------------------------------------------------------
//  491 //int16_t CModbus::ReportSlaveID(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  492 //{
//  493 //    uint16_t uiOffset = HEADER_LENGTH;
//  494 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  495 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  496 //
//  497 //    uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  498 //    puiResponse[uiLength++] = 3;			// Число байт данных
//  499 //    puiResponse[uiLength++] = 32;			// Количество окон сигнализации
//  500 //    puiResponse[uiLength++] = 7;			// Код модификации
//  501 //    puiResponse[uiLength++] = 50;			// Код устройства
//  502 //
//  503 //    return uiLength;
//  504 //}
//  505 
//  506 ////-----------------------------------------------------------------------------------------------------
//  507 //int16_t CModbus::Programming(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  508 //{
//  509 //// Функция 0x46 "программирование". Описание протокола обмена:
//  510 //// Buff[0] - адрес Slave.
//  511 //// Buff[1] - код функции.
//  512 //// Buff[2] - количество байт в запросе команды старший байт.
//  513 //// Buff[3] - количество байт в запросе команды младший байт.
//  514 //// Buff[4] - код операции(0 - запрос версии ПО, 1 - чтение блокаБД, 2 - запись блокаБД).
//  515 //// Buff[5] - номер блока БД.
//  516 //
//  517 //    // Смещения в принятом буфере.
//  518 //    enum
//  519 //    {
//  520 //        REQUEST_LENGTH = 2,
//  521 //        REQUEST_COMMAND = 3,
//  522 //        BLOCK_NUMBER = 4,
//  523 //        DATA_BEGIN = 5,
//  524 //    };
//  525 //
//  526 //    uint16_t uiOffset = HEADER_LENGTH;
//  527 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  528 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  529 //
//  530 //    uint16_t uiNumberB = (static_cast<uint16_t>(puiRequest[uiOffset + REQUEST_LENGTH]));
//  531 //
//  532 //    if (uiNumberB != (uiLength - 6))
//  533 //    {
//  534 //        uiLength = ResponseException(uiSlave,
//  535 //                                     uiFunctionCode,
//  536 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  537 //                                     puiResponse);
//  538 //    }
//  539 //    else
//  540 //    {
//  541 //        uint8_t uiBlockNumber;
//  542 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  543 //        // Какой код операции?
//  544 //        switch(puiRequest[uiOffset + REQUEST_COMMAND])
//  545 //        {
//  546 //        case 0x00:
//  547 //            // Получение версии ПО.
//  548 //            puiResponse[uiLength++] = 0;
//  549 //            puiResponse[uiLength++] = 4;
//  550 //            puiResponse[uiLength++] = puiRequest[uiOffset + REQUEST_COMMAND];
//  551 //            puiResponse[uiLength++] = 1; // 1.7.01
//  552 //            puiResponse[uiLength++] = 7;
//  553 //            puiResponse[uiLength++] = 0x01;
//  554 //            break;
//  555 //
//  556 //        case 0x01:
//  557 //            // Чтение блока БД.
//  558 //            uiBlockNumber = puiRequest[uiOffset + BLOCK_NUMBER];
//  559 //            // Блок не существует?
//  560 //            if (uiBlockNumber > CDataBase::BLOCKS_QUANTITY)
//  561 //            {
//  562 //                uiLength = ResponseException(uiSlave,
//  563 //                                             uiFunctionCode,
//  564 //                                             MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  565 //                                             puiResponse);
//  566 //            }
//  567 //            else
//  568 //            {
//  569 //                // Прочитаем блок БД.
//  570 //                uint16_t uiLengthLocal = CDataBase::Read(&puiResponse[uiOffset + DATA_BEGIN], uiBlockNumber);
//  571 //                puiResponse[uiLength++] = 0;
//  572 //                puiResponse[uiLength++] = uiLengthLocal;
//  573 //                puiResponse[uiLength++] = puiRequest[uiOffset + REQUEST_COMMAND];
//  574 //                puiResponse[uiLength++] = uiBlockNumber;
//  575 //                uiLength += uiLengthLocal;
//  576 //            }
//  577 //            break;
//  578 //
//  579 //
//  580 //        case 0x02:
//  581 //            // Запись блока БД.
//  582 //            uiBlockNumber = puiRequest[uiOffset + BLOCK_NUMBER];
//  583 //            // Блок не существует?
//  584 //            if (uiBlockNumber > CDataBase::BLOCKS_QUANTITY)
//  585 //            {
//  586 //                uiLength = ResponseException(uiSlave,
//  587 //                                             uiFunctionCode,
//  588 //                                             MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  589 //                                             puiResponse);
//  590 //            }
//  591 //            // Размер блока не соответствует?
//  592 //            else if (puiRequest[uiOffset + REQUEST_LENGTH] != CDataBase::m_DStruct[uiBlockNumber].Size)
//  593 //            {
//  594 //                uiLength = ResponseException(uiSlave,
//  595 //                                             uiFunctionCode,
//  596 //                                             MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  597 //                                             puiResponse);
//  598 //            }
//  599 //            else
//  600 //            {
//  601 //                // Сохраним блок БД.
//  602 //                // Успешно?
//  603 //                if (CDataBase::Write(&puiRequest[uiOffset + DATA_BEGIN], uiBlockNumber))
//  604 //                {
//  605 //                    CDataBase::SetStatus(1);
//  606 //                }
//  607 //                else
//  608 //                {
//  609 //                    CDataBase::SetStatus(0);
//  610 //                }
//  611 //            }
//  612 //            break;
//  613 //
//  614 //
//  615 //        case 0x03:
//  616 //            if(!(CDataBase::GetStatus()))
//  617 //            {
//  618 //                uiLength = ResponseException(uiSlave,
//  619 //                                             uiFunctionCode,
//  620 //                                             MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  621 //                                             puiResponse);
//  622 //            }
//  623 //            break;
//  624 //
//  625 //        default:
//  626 //            uiLength = ResponseException(uiSlave,
//  627 //                                         uiFunctionCode,
//  628 //                                         MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  629 //                                         puiResponse);
//  630 //            break;
//  631 //        };
//  632 //    }
//  633 //
//  634 //    return uiLength;
//  635 //}
//  636 //
//  637 ////-----------------------------------------------------------------------------------------------------
//  638 //int16_t CModbus::PollProgramming(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  639 //
//  640 //{
//  641 //    uint16_t uiOffset = HEADER_LENGTH;
//  642 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  643 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  644 //
//  645 //    if(!(CDataBase::GetStatus()))
//  646 //    {
//  647 //        uiLength = ResponseException(uiSlave,
//  648 //                                     uiFunctionCode,
//  649 //                                     MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  650 //                                     puiResponse);
//  651 //    }
//  652 //    else
//  653 //    {
//  654 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  655 //    }
//  656 //
//  657 ////    if(Storage::GetStatus() != Storage::IDLE)
//  658 ////    {
//  659 ////        return ModBus::SLAVE_DEVICE_BUSY;
//  660 ////    }
//  661 //
//  662 //    return uiLength;
//  663 //}
//  664 
//  665 ////-----------------------------------------------------------------------------------------------------
//  666 //int16_t CModbus::Reply(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiFrameLength)
//  667 //{
//  668 //    uint16_t uiOffset = HEADER_LENGTH;
//  669 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  670 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  671 //    uint16_t uiLength = uiFrameLength;
//  672 //
//  673 //    /* Filter on the Modbus unit identifier (slave) in RTU mode */
//  674 //    if (uiSlave != m_uiOwnAddress && uiSlave != MODBUS_BROADCAST_ADDRESS)
//  675 //    {
//  676 //        return 0;
//  677 //    }
//  678 //
//  679 //    switch (uiFunctionCode)
//  680 //    {
//  681 ////    case _FC_READ_COILS:
//  682 ////        uiLength = ReadCoils(puiRequest, puiResponse, uiLength);
//  683 ////        break;
//  684 ////
//  685 //    case _FC_READ_DISCRETE_INPUTS:
//  686 //        uiLength = ReadDiscreteInputs(puiRequest, puiResponse, uiLength);
//  687 //        break;
//  688 //
//  689 ////    case _FC_READ_HOLDING_REGISTERS:
//  690 ////        uiLength = ReadHoldingRegisters(puiRequest, puiResponse, uiLength);
//  691 ////        break;
//  692 ////
//  693 ////    case _FC_READ_INPUT_REGISTERS:
//  694 ////        uiLength = ReadInputRegisters(puiRequest, puiResponse, uiLength);
//  695 ////        break;
//  696 ////
//  697 ////    case _FC_WRITE_SINGLE_COIL:
//  698 ////        uiLength = WriteSingleCoil(puiRequest, puiResponse, uiLength);
//  699 ////        break;
//  700 ////
//  701 ////    case _FC_WRITE_SINGLE_REGISTER:
//  702 ////        uiLength = WriteSingleRegister(puiRequest, puiResponse, uiLength);
//  703 ////        break;
//  704 ////
//  705 ////    case _FC_READ_EXCEPTION_STATUS:
//  706 ////        uiLength = ReadExceptionStatus(puiRequest, puiResponse, uiLength);
//  707 ////        break;
//  708 ////
//  709 ////    case _FC_WRITE_MULTIPLE_COILS:
//  710 ////        uiLength = WriteMultipleCoils(puiRequest, puiResponse, uiLength);
//  711 ////        break;
//  712 ////
//  713 ////    case _FC_PROGRAMMING_COMPLETION_REQUEST:
//  714 ////        break;
//  715 ////
//  716 ////    case _FC_WRITE_MULTIPLE_REGISTERS:
//  717 ////        uiLength = WriteMultipleRegisters(puiRequest, puiResponse, uiLength);
//  718 ////        break;
//  719 ////
//  720 ////    case _FC_REPORT_SLAVE_ID:
//  721 ////        uiLength = ReportSlaveID(puiRequest, puiResponse, uiLength);
//  722 ////        break;
//  723 ////
//  724 ////    case _FC_WRITE_AND_READ_REGISTERS:
//  725 ////        uiLength = WriteAndReadRegisters(puiRequest, puiResponse, uiLength);
//  726 ////        break;
//  727 ////
//  728 ////    case _FC_DATA_EXCHANGE:
//  729 ////        break;
//  730 ////
//  731 ////    case _FC_DATA_BASE_READ:
//  732 ////        break;
//  733 ////
//  734 ////    case _FC_DATA_BASE_WRITE:
//  735 ////        break;
//  736 ////
//  737 ////    case _FC_PROGRAMMING:
//  738 ////        uiLength = Programming(puiRequest, puiResponse, uiLength);
//  739 ////        break;
//  740 //
//  741 //    default:
//  742 //        uiLength = ResponseException(uiSlave,
//  743 //                                     uiFunctionCode,
//  744 //                                     MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  745 //                                     puiResponse);
//  746 //        break;
//  747 //    }
//  748 //
//  749 //    m_uiMessageLength = uiLength;
//  750 //    return uiLength;
//  751 ////    return SendMessage(puiResponse, uiLength);
//  752 //}
//  753 
//  754 ////-----------------------------------------------------------------------------------------------------
//  755 //void CModbus::SetByteFromBits(uint8_t *dest, int16_t index, const uint8_t value)
//  756 //{
//  757 //    int16_t i;
//  758 //
//  759 //    for (i=0; i<8; i++)
//  760 //    {
//  761 //        dest[index+i] = (value & (1 << i)) ? 1 : 0;
//  762 //    }
//  763 //}
//  764 //
//  765 ////-----------------------------------------------------------------------------------------------------
//  766 //void CModbus::SetBytesFromBits(uint8_t *dest, int16_t index, uint16_t nb_bits,
//  767 //                               const uint8_t *tab_byte)
//  768 //{
//  769 //    int16_t i;
//  770 //    int16_t shift = 0;
//  771 //
//  772 //    for (i = index; i < index + nb_bits; i++)
//  773 //    {
//  774 //        dest[i] = tab_byte[(i - index) / 8] & (1 << shift) ? 1 : 0;
//  775 //        /* gcc doesn't like: shift = (++shift) % 8; */
//  776 //        shift++;
//  777 //        shift %= 8;
//  778 //    }
//  779 //}
//  780 //
//  781 ////-----------------------------------------------------------------------------------------------------
//  782 //uint8_t CModbus::GetByteFromBits(const uint8_t *src, int16_t index,
//  783 //                                 uint16_t nb_bits)
//  784 //{
//  785 //    int16_t i;
//  786 //    uint8_t value = 0;
//  787 //
//  788 //    if (nb_bits > 8)
//  789 //    {
//  790 //        /* Assert is ignored if NDEBUG is set */
//  791 ////        assert(nb_bits < 8); //?
//  792 //        nb_bits = 8;
//  793 //    }
//  794 //
//  795 //    for (i=0; i < nb_bits; i++)
//  796 //    {
//  797 //        value |= (src[index+i] << i);
//  798 //    }
//  799 //
//  800 //    return value;
//  801 //}
//  802 //
//  803 ////-----------------------------------------------------------------------------------------------------
//  804 //float CModbus::GetFloat(const uint16_t *src)
//  805 //{
//  806 //    float f = 0.0f;
//  807 //    uint32_t i;
//  808 //
//  809 //    i = (((uint32_t)src[1]) << 16) + src[0];
//  810 //    memcpy(&f, &i, sizeof(float));
//  811 //
//  812 //    return f;
//  813 //}
//  814 //
//  815 ////-----------------------------------------------------------------------------------------------------
//  816 //void CModbus::SetFloat(float f, uint16_t *dest)
//  817 //{
//  818 //    uint32_t i = 0;
//  819 //
//  820 //    memcpy(&i, &f, sizeof(uint32_t));
//  821 //    dest[0] = (uint16_t)i;
//  822 //    dest[1] = (uint16_t)(i >> 16);
//  823 //}
//  824 
//  825 //-----------------------------------------------------------------------------------------------------
//  826 
//  827 
//  828 
//  829 
//  830 
//  831 
//  832 ////-----------------------------------------------------------------------------------------------------
//  833 //uint8_t CModbus::CheckConfirmation(uint8_t *puiResponse, uint16_t uiLength)
//  834 //{
//  835 //    uint16_t uiOffset = HEADER_LENGTH;
//  836 //    int8_t uiSlave = puiResponse[uiOffset - 1];
//  837 //    int8_t uiFunctionCode = puiResponse[uiOffset];
//  838 //
//  839 //    if ((m_uiOwnAddress == uiSlave) &&
//  840 //            (m_uiFunctionCode == uiFunctionCode))
//  841 //    {
//  842 //        return 1;
//  843 //    }
//  844 //    else if (uiLength == (uiOffset + 2 + CRC_LENGTH) &&
//  845 //             (uiFunctionCode & 0x80))
//  846 //    {
//  847 //        /* EXCEPTION CODE RECEIVED */
//  848 //        int8_t uiExceptionCode =
//  849 //            puiResponse[uiOffset + MODBUS_EXCEPTION_CODE_OFFSET];
//  850 //        if (uiExceptionCode < MODBUS_EXCEPTION_MAX)
//  851 //        {
//  852 //            return MODBUS_ENOBASE + uiExceptionCode;
//  853 //        }
//  854 //        else
//  855 //        {
//  856 //            return EMBBADEXC;
//  857 //        }
//  858 //    }
//  859 //}
//  860 
//  861 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  862 int8_t CModbus::ReadDiscreteInputsRequest(uint8_t uiSlaveAddress,
??ReadDiscreteInputsRequest:
//  863         uint16_t uiAddress,
//  864         uint16_t uiBitNumber)
//  865 {
        RCALL   ?PROLOGUE4_L09
//  866     if (uiBitNumber > MODBUS_MAX_READ_BITS)
        CPI     R20, 209
        LDI     R17, 7
        CPC     R21, R17
        BRCS    ??ReadDiscreteInputsRequest_1
//  867     {
//  868         return EMBMDATA;
        LDI     R16, 16
        RJMP    ??ReadDiscreteInputsRequest_2
//  869     }
//  870 
//  871     if (MessengerIsReady() == 1)
??ReadDiscreteInputsRequest_1:
        LDI     R26, LOW(??m_uiQuantity)
        LDI     R27, (??m_uiQuantity) >> 8
        LDS     R17, (??m_uiQuantity + 8)
        TST     R17
        BREQ    ??ReadDiscreteInputsRequest_3
//  872     {
//  873         m_uiFunctionCode = _FC_READ_DISCRETE_INPUTS;
//  874         m_uiQuantity = uiBitNumber;
//  875         m_uiMessageLength = CModbusRTU::RequestBasis(uiSlaveAddress,
//  876                             m_uiFunctionCode,
//  877                             uiAddress,
//  878                             uiBitNumber,
//  879                             m_puiTxBuffer);
//  880         FlowControlSet(FRAME_TRANSMIT_REQUEST);
//  881         return 1;
//  882     }
//  883     else
//  884     {
//  885         return 0;
        LDI     R16, 0
        RJMP    ??ReadDiscreteInputsRequest_2
//  886     }
??ReadDiscreteInputsRequest_3:
        LDI     R17, 2
        STS     (??m_uiQuantity + 7), R17
        ST      X+, R20
        ST      X, R21
        SBIW    R27:R26, 1
        MOVW    R31:R30, R27:R26
        LDD     R22, Z+4
        LDD     R23, Z+5
        RCALL   ??RequestBasis
        MOVW    R31:R30, R27:R26
        STD     Z+2, R16
        STD     Z+3, R17
        LDI     R16, 14
        STD     Z+8, R16
        LDI     R16, 1
??ReadDiscreteInputsRequest_2:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  887 }
//  888 
//  889 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  890 int16_t CModbus::ReadDiscreteInputsReceive(uint8_t *puiMessage, uint16_t uiLength)
??ReadDiscreteInputsReceive:
//  891 {
        RCALL   ?PROLOGUE5_L09
        REQUIRE ?Register_R4_is_cg_reg
        MOVW    R3:R2, R17:R16
//  892     uint8_t uiByteCounter = 0;
        LDI     R26, 0
//  893     for (int8_t i = 0; i < (m_uiQuantity / 2); )
        LDI     R22, 0
        LDI     R30, LOW(??m_uiQuantity)
        LDI     R31, (??m_uiQuantity) >> 8
        LD      R24, Z
        LDD     R25, Z+1
        RJMP    ??ReadDiscreteInputsReceive_1
//  894     {
//  895         uint8_t uiData = puiMessage[uiByteCounter];
//  896         for (uint8_t j = 0; j < CHANNELS_IN_BYTE; j++)
??ReadDiscreteInputsReceive_2:
        DEC     R21
        BRNE    ??ReadDiscreteInputsReceive_3
//  897         {
//  898             uint8_t uiState = 0;
//  899             for (uint8_t k = 0; k < MEASURE_CHANNEL_STATE_BIT_NUMBER; k++)
//  900             {
//  901                 if (uiData & 0x01)
//  902                 {
//  903                     uiState |= (0x01 << k);
//  904                 }
//  905                 uiData >>= 1;
//  906             }
//  907 
//  908             CMvsn21::axChipsChannelsData[m_uiSlaveAddress - 1].axMeasurementChannels[i].uiState = uiState;
//  909             // Следующий дискретный вход.
//  910             i++;
//  911             // Распаковали все данные состояния дискретных входов?
//  912             if (i >= m_uiQuantity)
//  913             {
//  914                 // Распаковали все данные состояния дискретных входов.
//  915                 return 1;
//  916             }
//  917         }
//  918         uiByteCounter += 1;
        INC     R26
??ReadDiscreteInputsReceive_1:
        RCALL   ?Subroutine0
??CrossCallReturnLabel_0:
        MOVW    R17:R16, R25:R24
        LSR     R17
        ROR     R16
        CP      R22, R16
        CPC     R23, R17
        BRCC    ??ReadDiscreteInputsReceive_4
        LDI     R27, 0
        MOVW    R31:R30, R3:R2
        ADD     R30, R26
        ADC     R31, R27
        LD      R27, Z
        LDI     R21, 4
??ReadDiscreteInputsReceive_3:
        CLR     R4
        LDI     R19, 0
        LDI     R18, 2
??ReadDiscreteInputsReceive_5:
        BST     R27, 0
        BRTC    ??ReadDiscreteInputsReceive_6
        RCALL   ?Subroutine1
??CrossCallReturnLabel_4:
        MOV     R20, R19
        RCALL   ?S_SHL_L02
        OR      R4, R16
??ReadDiscreteInputsReceive_6:
        LSR     R27
        INC     R19
        DEC     R18
        BRNE    ??ReadDiscreteInputsReceive_5
        LDI     R30, LOW((??axChipsChannelsData - 8))
        LDI     R31, HIGH((??axChipsChannelsData - 8))
        RCALL   ?Subroutine0
??CrossCallReturnLabel_1:
        ADD     R30, R22
        ADC     R31, R23
        LDS     R16, (??m_uiQuantity + 6)
        LDI     R17, 8
        MUL     R16, R17
        ADD     R30, R0
        ADC     R31, R1
        ST      Z, R4
        INC     R22
        RCALL   ?Subroutine0
//  919     }
??CrossCallReturnLabel_2:
        CP      R22, R24
        CPC     R23, R25
        BRCS    ??ReadDiscreteInputsReceive_2
//  920     return 1;
??ReadDiscreteInputsReceive_4:
        RCALL   ?Subroutine1
??CrossCallReturnLabel_5:
        LDI     R30, 5
        RJMP    ?EPILOGUE_B5_L09
//  921 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
        LDI     R16, 1
        LDI     R17, 0
        RET

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
        MOV     R23, R22
        LSL     R23
        SBC     R23, R23
        RET
//  922 
//  923 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  924 int16_t CModbus::ReceiveMessage(uint8_t *puiResponse, uint16_t uiFrameLength)
??ReceiveMessage:
//  925 {
//  926     uint16_t uiOffset = HEADER_LENGTH;
//  927     uint8_t uiSlave = puiResponse[uiOffset - 1];
//  928     uint8_t uiFunctionCode = puiResponse[uiOffset];
        MOVW    R31:R30, R17:R16
        LDD     R20, Z+1
//  929     uint16_t uiLength = uiFrameLength;
//  930 
//  931     if ((m_uiSlaveAddress == uiSlave) &&
//  932             (m_uiFunctionCode == uiFunctionCode))
        LDS     R21, (??m_uiQuantity + 6)
        LD      R22, Z
        CP      R21, R22
        BRNE    ??ReceiveMessage_1
        LDS     R21, (??m_uiQuantity + 7)
        CP      R21, R20
        BRNE    ??ReceiveMessage_1
//  933     {
//  934         switch (uiFunctionCode)
        CPI     R20, 2
        BRNE    ??ReceiveMessage_2
//  935         {
//  936 //    case _FC_READ_COILS:
//  937 //        break;
//  938 //
//  939         case _FC_READ_DISCRETE_INPUTS:
//  940             ReadDiscreteInputsReceive(&puiResponse[uiOffset + 2], uiLength);
        SUBI    R16, 253
        SBCI    R17, 255
        RCALL   ??ReadDiscreteInputsReceive
//  941             break;
//  942 
//  943 //    case _FC_READ_HOLDING_REGISTERS:
//  944 //        break;
//  945 //
//  946 //    case _FC_READ_INPUT_REGISTERS:
//  947 //        break;
//  948 //
//  949 //    case _FC_WRITE_SINGLE_COIL:
//  950 //        break;
//  951 //
//  952 //    case _FC_WRITE_SINGLE_REGISTER:
//  953 //        break;
//  954 //
//  955 //    case _FC_READ_EXCEPTION_STATUS:
//  956 //        break;
//  957 //
//  958 //    case _FC_WRITE_MULTIPLE_COILS:
//  959 //        break;
//  960 //
//  961 //    case _FC_PROGRAMMING_COMPLETION_REQUEST:
//  962 //        break;
//  963 //
//  964 //    case _FC_WRITE_MULTIPLE_REGISTERS:
//  965 //        break;
//  966 //
//  967 //    case _FC_REPORT_SLAVE_ID:
//  968 //        break;
//  969 //
//  970 //    case _FC_WRITE_AND_READ_REGISTERS:
//  971 //        break;
//  972 //
//  973 //    case _FC_DATA_EXCHANGE:
//  974 //        break;
//  975 //
//  976 //    case _FC_DATA_BASE_READ:
//  977 //        break;
//  978 //
//  979 //    case _FC_DATA_BASE_WRITE:
//  980 //        break;
//  981 //
//  982 //    case _FC_PROGRAMMING:
//  983 //        break;
//  984 
//  985         default:
//  986             break;
//  987         }
//  988         return 1;
??ReceiveMessage_2:
        RJMP    ?Subroutine1
//  989     }
//  990     else if (uiLength == (uiOffset + 2 + CRC_LENGTH) &&
//  991              (uiFunctionCode & 0x80))
??ReceiveMessage_1:
        CPI     R18, 5
        SBCI    R19, 0
        BRNE    ??ReceiveMessage_3
        BST     R20, 7
        BRTC    ??ReceiveMessage_3
//  992     {
//  993         /* EXCEPTION CODE RECEIVED */
//  994         int8_t uiExceptionCode =
//  995             puiResponse[uiOffset + MODBUS_EXCEPTION_CODE_OFFSET];
        LDD     R16, Z+2
//  996         if (uiExceptionCode < MODBUS_EXCEPTION_MAX)
        CPI     R16, 12
        BRGE    ??ReceiveMessage_4
//  997         {
//  998             return MODBUS_ENOBASE + uiExceptionCode;
        MOV     R17, R16
        LSL     R17
        SBC     R17, R17
        RET
//  999         }
// 1000         else
// 1001         {
// 1002             return EMBBADEXC;
??ReceiveMessage_4:
        LDI     R16, 14
        LDI     R17, 0
// 1003         }
// 1004     }
// 1005 }
??ReceiveMessage_3:
        RET

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0

        END
// 
//  87 bytes in segment ABSOLUTE
// 398 bytes in segment CODE
//   6 bytes in segment INITTAB
//   2 bytes in segment NEAR_F
//  18 bytes in segment NEAR_Z
// 
// 400 bytes of CODE memory (+  6 bytes shared)
//  18 bytes of DATA memory (+ 87 bytes shared)
//
//Errors: none
//Warnings: 6
