///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR          29/Jun/2023  11:21:55
// Copyright 1996-2018 IAR Systems AB.
//
//    Source file  =  
//        D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\src\Mvsn21.cpp
//    Command line =  
//        -f C:\Users\Admin\AppData\Local\Temp\EWF324.tmp
//        (--string_literals_in_flash
//        D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\src\Mvsn21.cpp
//        --cpu=m48 -ms -o
//        D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\Debug\Obj -lB
//        D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\Debug\List
//        --initializers_in_flash --root_variables --debug
//        -DENABLE_BIT_DEFINITIONS -e -I
//        D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\include\ -I
//        D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\Modbus\
//        --eeprom_size 256 --dlib --dlib_config "C:\Program Files (x86)\IAR
//        Systems\Embedded Workbench 8.0\avr\LIB\DLIB\dlAVR-1s-ec_mul-n.h" -Ohz
//        --eec++)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\Debug\List\Mvsn21.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME Mvsn21

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B6_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE6_L09
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC ??MeasureFsm
        PUBLIC ??ReadData
        PUBLIC ??ReportType
        PUBLIC ??SpiBusExchangeEnable
        PUBLIC ??SpiFsm
        PUBLIC ??SpiReply
        PUBLIC ??m_aucRtuDiscreteInputsArray
        PUBLIC ??m_aui8ReceiveMessageBuff
        PUBLIC ??m_aui8TransmitMessageBuff
        PUBLIC ??m_axMeasurementChannelRemap
        PUBLIC ??m_axSameStateCheck
        PUBLIC ??m_uiChannel
        PUBLIC ??m_uiFlowControl
        PUBLIC ??m_uiMeasureFlowControl
        PUBLIC ??m_uiMessageLength
        PUBLIC ??m_uiStartSkippedCyclesNumber
        PUBLIC ??m_uiType
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADCSRB
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_CLKPR
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_DIDR0
        PUBWEAK _A_DIDR1
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_EICRA
        PUBWEAK _A_EIFR
        PUBWEAK _A_EIMSK
        PUBWEAK _A_GPIOR0
        PUBWEAK _A_GPIOR1
        PUBWEAK _A_GPIOR2
        PUBWEAK _A_GTCCR
        PUBWEAK _A_ICR1
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUSR
        PUBWEAK _A_OCR0A
        PUBWEAK _A_OCR0B
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR2A
        PUBWEAK _A_OCR2B
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PCICR
        PUBWEAK _A_PCIFR
        PUBWEAK _A_PCMSK0
        PUBWEAK _A_PCMSK1
        PUBWEAK _A_PCMSK2
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_PRR
        PUBWEAK _A_SMCR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0A
        PUBWEAK _A_TCCR0B
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR1C
        PUBWEAK _A_TCCR2A
        PUBWEAK _A_TCCR2B
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TIFR0
        PUBWEAK _A_TIFR1
        PUBWEAK _A_TIFR2
        PUBWEAK _A_TIMSK0
        PUBWEAK _A_TIMSK1
        PUBWEAK _A_TIMSK2
        PUBWEAK _A_TWAMR
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRR0
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UCSR0C
        PUBWEAK _A_UDR0
        PUBWEAK _A_WDTCSR
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

`?<Name CSpi 8>`    SYMBOL "CSpi"
`?<Name CModbus 21>` SYMBOL "CModbus"
??m_bfByteIsReceived SYMBOL "m_bfByteIsReceived", `?<Name CSpi 8>`
??m_puiRxBuffer     SYMBOL "m_puiRxBuffer", `?<Name CSpi 8>`
??m_puiTxBuffer     SYMBOL "m_puiTxBuffer", `?<Name CSpi 8>`
??m_uiErrorCode     SYMBOL "m_uiErrorCode", `?<Name CSpi 8>`
??m_uiSlaveAddress  SYMBOL "m_uiSlaveAddress", `?<Name CModbus 21>`
`?<Name CMvsn21 42>` SYMBOL "CMvsn21"
??m_aucRtuDiscreteInputsArray SYMBOL "m_aucRtuDiscreteInputsArray", `?<Name CMvsn21 42>`
??m_aui8ReceiveMessageBuff SYMBOL "m_aui8ReceiveMessageBuff", `?<Name CMvsn21 42>`
??m_aui8TransmitMessageBuff SYMBOL "m_aui8TransmitMessageBuff", `?<Name CMvsn21 42>`
??m_axMeasurementChannelRemap SYMBOL "m_axMeasurementChannelRemap", `?<Name CMvsn21 42>`
??m_axSameStateCheck SYMBOL "m_axSameStateCheck", `?<Name CMvsn21 42>`
??m_uiChannel       SYMBOL "m_uiChannel", `?<Name CMvsn21 42>`
??m_uiFlowControl   SYMBOL "m_uiFlowControl", `?<Name CMvsn21 42>`
??m_uiMeasureFlowControl SYMBOL "m_uiMeasureFlowControl", `?<Name CMvsn21 42>`
??m_uiMessageLength SYMBOL "m_uiMessageLength", `?<Name CMvsn21 42>`
??m_uiStartSkippedCyclesNumber SYMBOL "m_uiStartSkippedCyclesNumber", `?<Name CMvsn21 42>`
??m_uiType          SYMBOL "m_uiType", `?<Name CMvsn21 42>`

        EXTERN ??ChannelSelect
        EXTERN ??Disable
        EXTERN ??Enable
        EXTERN ??Exchange
        EXTERN ??GetMeasureValue
        EXTERN ??Int0InterruptEnable
        EXTERN ??ReadDiscreteInputsRequest
        EXTERN ??Reset
        EXTERN ??Start
        EXTERN ??StateCheck
        EXTERN ??Stop
        EXTERN ??m_bfByteIsReceived
        EXTERN ??m_puiRxBuffer
        EXTERN ??m_puiTxBuffer
        EXTERN ??m_uiErrorCode
        EXTERN ??m_uiSlaveAddress
        EXTERN ??usCrcSummOneByteCalculation

// D:\Projects\CurrentProjects\CautoProjects\Mvsn21\Mvsn21\src\Mvsn21.cpp
//    1 //-----------------------------------------------------------------------------------------------------
//    2 //  Source      : FileName.cpp
//    3 //  Created     : 01.06.2022
//    4 //  Author      : Alexandr Volvenkin
//    5 //  email       : aav-36@mail.ru
//    6 //  GitHub      : https://github.com/AlexandrVolvenkin
//    7 //-----------------------------------------------------------------------------------------------------
//    8 
//    9 #include "Mvsn21.h"
//   10 #include "Platform.h"

        ASEGN ABSOLUTE:DATA:ROOT,0c6H
// union <unnamed> volatile __io _A_UDR0
_A_UDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c4H
// union <unnamed> volatile __io _A_UBRR0
_A_UBRR0:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,0c2H
// union <unnamed> volatile __io _A_UCSR0C
_A_UCSR0C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c1H
// union <unnamed> volatile __io _A_UCSR0B
_A_UCSR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c0H
// union <unnamed> volatile __io _A_UCSR0A
_A_UCSR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bdH
// union <unnamed> volatile __io _A_TWAMR
_A_TWAMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bcH
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bbH
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0baH
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b9H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b8H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b6H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b4H
// union <unnamed> volatile __io _A_OCR2B
_A_OCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b3H
// union <unnamed> volatile __io _A_OCR2A
_A_OCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b2H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b1H
// union <unnamed> volatile __io _A_TCCR2B
_A_TCCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b0H
// union <unnamed> volatile __io _A_TCCR2A
_A_TCCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08aH
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,088H
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,086H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,084H
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,082H
// union <unnamed> volatile __io _A_TCCR1C
_A_TCCR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,081H
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,080H
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07fH
// union <unnamed> volatile __io _A_DIDR1
_A_DIDR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07eH
// union <unnamed> volatile __io _A_DIDR0
_A_DIDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07cH
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07bH
// union <unnamed> volatile __io _A_ADCSRB
_A_ADCSRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07aH
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,078H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,070H
// union <unnamed> volatile __io _A_TIMSK2
_A_TIMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06fH
// union <unnamed> volatile __io _A_TIMSK1
_A_TIMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06eH
// union <unnamed> volatile __io _A_TIMSK0
_A_TIMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06dH
// union <unnamed> volatile __io _A_PCMSK2
_A_PCMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06cH
// union <unnamed> volatile __io _A_PCMSK1
_A_PCMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06bH
// union <unnamed> volatile __io _A_PCMSK0
_A_PCMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,069H
// union <unnamed> volatile __io _A_EICRA
_A_EICRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,068H
// union <unnamed> volatile __io _A_PCICR
_A_PCICR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,066H
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,064H
// union <unnamed> volatile __io _A_PRR
_A_PRR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,061H
// union <unnamed> volatile __io _A_CLKPR
_A_CLKPR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,060H
// union <unnamed> volatile __io _A_WDTCSR
_A_WDTCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUSR
_A_MCUSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_SMCR
_A_SMCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04dH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04bH
// union <unnamed> volatile __io _A_GPIOR2
_A_GPIOR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_GPIOR1
_A_GPIOR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR0B
_A_OCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,047H
// union <unnamed> volatile __io _A_OCR0A
_A_OCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR0B
_A_TCCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCCR0A
_A_TCCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_GTCCR
_A_GTCCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03fH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_GPIOR0
_A_GPIOR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EIMSK
_A_EIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EIFR
_A_EIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PCIFR
_A_PCIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_TIFR2
_A_TIFR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_TIFR1
_A_TIFR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_TIFR0
_A_TIFR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,025H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS8 1
//   11 #include "Crc.h"
//   12 #include "Modbus.h"
//   13 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   14 uint8_t CMvsn21::m_uiType;
??m_uiType:
        DS8 1
//   15 //CDriver* CMvsn21::m_pxDriver;

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   16 uint8_t CMvsn21::m_uiFlowControl;
//   17 uint16_t CMvsn21::m_uiMessageLength;
??m_uiMessageLength:
        DS8 2
??m_uiFlowControl:
        DS8 1
//   18 uint8_t CMvsn21::m_uiChannel;

        RSEG NEAR_I:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
//   19 uint8_t CMvsn21::m_uiStartSkippedCyclesNumber;
//   20 uint8_t CMvsn21::m_uiMeasureFlowControl;
//   21 // Сопоставление входа каналу.
//   22 __flash TChannelRemap CMvsn21::m_axMeasurementChannelRemap[] =
??m_axMeasurementChannelRemap:
        DS8 48
        REQUIRE `?<Initializer for m_axMeasurementChannelRemap>`
??m_uiStartSkippedCyclesNumber:
        DS8 1
        REQUIRE `?<Initializer for m_uiStartSkippedCyclesNumber`

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   23 {
//   24     // Нумерация входов сверху вниз.
//   25     // разъём X1.
//   26     {0, 6},
//   27     {0, 7},
//   28     {0, 0},
//   29     {0, 1},
//   30     {0, 2},
//   31     {0, 3},
//   32     // разъём X2.
//   33     {0, 4},
//   34     {0, 5},
//   35     {1, 6},
//   36     {1, 7},
//   37     {1, 0},
//   38     {1, 1},
//   39     // разъём X3.
//   40     {1, 2},
//   41     {1, 3},
//   42     {1, 4},
//   43     {1, 5},
//   44     {2, 6},
//   45     {2, 7},
//   46     // разъём X4.
//   47     {2, 0},
//   48     {2, 1},
//   49     {2, 2},
//   50     {2, 3},
//   51     {2, 4},
//   52     {2, 5},
//   53 };
//   54 
//   55 TSameStateCheck CMvsn21::m_axSameStateCheck[];
??m_axSameStateCheck:
        DS8 16
??m_uiChannel:
        DS8 1
??m_uiMeasureFlowControl:
        DS8 1
//   56 //uint8_t CMvsn21::m_aucRtuCoilsArray[];

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   57 uint8_t CMvsn21::m_aucRtuDiscreteInputsArray[];
??m_aucRtuDiscreteInputsArray:
        DS8 48
//   58 //uint16_t CMvsn21::m_aucRtuHoldingRegistersArray[];
//   59 //uint16_t CMvsn21::m_aucRtuInputRegistersArray[];

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   60 uint8_t CMvsn21::m_aui8ReceiveMessageBuff[];
??m_aui8ReceiveMessageBuff:
        DS8 32

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   61 uint8_t CMvsn21::m_aui8TransmitMessageBuff[];
??m_aui8TransmitMessageBuff:
        DS8 32
//   62 //uint8_t CMvsn21::m_auiSpiRxBuffer[];
//   63 //uint8_t CMvsn21::m_auiSpiTxBuffer[];
//   64 
//   65 ////-----------------------------------------------------------------------------------------------------
//   66 //CMvsn21::CMvsn21(uint8_t uiType, CDriver* pxDriver)// :
//   67 ////    m_uiType(uiType),
//   68 ////    m_pxDriver(pxDriver)
//   69 //{
//   70 //
//   71 //}
//   72 
//   73 ////-----------------------------------------------------------------------------------------------------
//   74 //CMvsn21::CMvsn21(uint8_t uiType)// :
//   75 ////    m_uiType(uiType),
//   76 ////    m_pxDriver(pxDriver)
//   77 //{
//   78 //
//   79 //}
//   80 //
//   81 ////-----------------------------------------------------------------------------------------------------
//   82 //CMvsn21::~CMvsn21()
//   83 //{
//   84 //    //dtor
//   85 //}
//   86 
//   87 //////-----------------------------------------------------------------------------------------------------
//   88 ////void CMvsn21::SlaveSelectInterruptEnable(void)
//   89 ////{
//   90 ////
//   91 ////}
//   92 ////
//   93 //////-----------------------------------------------------------------------------------------------------
//   94 ////void CMvsn21::SlaveSelectInterruptDisable(void)
//   95 ////{
//   96 ////
//   97 ////}
//   98 //
//   99 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  100 void CMvsn21::SpiBusExchangeEnable(void)
??SpiBusExchangeEnable:
//  101 {
//  102     CPlatform::Int0InterruptEnable();
        RCALL   ??Int0InterruptEnable
//  103     m_uiFlowControl = FSM_START;
        LDI     R16, 1
        STS     (??m_uiMessageLength + 2), R16
//  104 }
        RET
//  105 
//  106 ////-----------------------------------------------------------------------------------------------------
//  107 //void CMvsn21::SpiBusExchangeDisable(void)
//  108 //{
//  109 //    CPlatform::Int0InterruptDisable();
//  110 //}
//  111 
//  112 ////-----------------------------------------------------------------------------------------------------
//  113 //void CMvsn21::Reset(void)
//  114 //{
//  115 //    CSpi::Reset();
//  116 //}
//  117 
//  118 ////-----------------------------------------------------------------------------------------------------
//  119 //uint8_t CMvsn21::Select(void)
//  120 //{
//  121 //    return CSpi::ByteIsReceived();
//  122 //}
//  123 
//  124 ////-----------------------------------------------------------------------------------------------------
//  125 //int16_t CMvsn21::Exchange(void)
//  126 //{
//  127 //    return CSpi::Exchange();
//  128 //}
//  129 
//  130 ////-----------------------------------------------------------------------------------------------------------------
//  131 //uint8_t CMvsn21::FrameIsReceived(void)
//  132 //{
//  133 //    return CSpi::m_bfDataExchangeIsOccur;
//  134 //};
//  135 //
//  136 ////-----------------------------------------------------------------------------------------------------------------
//  137 //uint16_t CMvsn21::GetFrameLength(void)
//  138 //{
//  139 //    return CSpi::GetFrameLength();
//  140 //}
//  141 
//  142 ////-----------------------------------------------------------------------------------------------------------------
//  143 //int8_t CMvsn21::FrameCheck(void)
//  144 //{
//  145 ////    if (CUart::m_nuiRxBuffByteCounter < _MIN_MESSAGE_LENGTH)
//  146 ////    {
//  147 ////        return 0;
//  148 ////    }
//  149 ////
//  150 ////    uint16_t uiCrc = ((static_cast<uint16_t>(m_puiRxBuffer[CUart::m_nuiRxBuffByteCounter - 2]) << 8) |
//  151 ////                      (static_cast<uint16_t>(m_puiRxBuffer[CUart::m_nuiRxBuffByteCounter - 1])));
//  152 ////
//  153 ////    if (usCrc16(m_puiRxBuffer,
//  154 ////                (CUart::m_nuiRxBuffByteCounter - _MVSN21_RTU_CHECKSUM_LENGTH)) == uiCrc)
//  155 ////    {
//  156 ////        return 1;
//  157 ////    }
//  158 ////    else
//  159 ////    {
//  160 ////        return 0;
//  161 ////    }
//  162 //}
//  163 //
//  164 ////-----------------------------------------------------------------------------------------------------------------
//  165 //int8_t CMvsn21::FrameCheck(uint8_t *puiSource, uint16_t uiLength)
//  166 //{
//  167 ////    if (uiLength < _MIN_MESSAGE_LENGTH)
//  168 ////    {
//  169 ////        return 0;
//  170 ////    }
//  171 ////
//  172 ////    uint16_t uiCrc = ((static_cast<uint16_t>(puiSource[uiLength - 2]) << 8) |
//  173 ////                      (static_cast<uint16_t>(puiSource[uiLength - 1])));
//  174 ////
//  175 ////    if (usCrc16(puiSource,
//  176 ////                (uiLength - _MVSN21_RTU_CHECKSUM_LENGTH)) == uiCrc)
//  177 ////    {
//  178 ////        return 1;
//  179 ////    }
//  180 ////    else
//  181 ////    {
//  182 ////        return 0;
//  183 ////    }
//  184 //}
//  185 
//  186 //-----------------------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  187 int16_t CMvsn21::ReportType(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
??ReportType:
//  188 {
//  189     uiLength = 0;
//  190     // Первый байт - пустой(эхо - заполняется в прерывании, SPDR = SPDR).
//  191     puiResponse[uiLength++] = 0;
        MOVW    R31:R30, R19:R18
        LDI     R16, 0
        ST      Z, R16
//  192     puiResponse[uiLength++] = MODULE_TYPE_MVSN21;
        LDI     R16, 1
        STD     Z+1, R16
//  193     puiResponse[uiLength++] = (COMMAND_REPORT_TYPE + MODULE_TYPE_MVSN21);
        LDI     R16, 146
        STD     Z+2, R16
//  194 
//  195     return uiLength;
        LDI     R16, 3
        LDI     R17, 0
        RET
//  196 }
//  197 
//  198 //-----------------------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  199 int16_t CMvsn21::ReadData(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
??ReadData:
//  200 {
        RCALL   ?PROLOGUE6_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        MOVW    R5:R4, R17:R16
        MOVW    R27:R26, R19:R18
//  201     uiLength = 0;
//  202 
//  203     // для того,чтобы определить текущее состояние входов нужно произвести
//  204     // измерения. это занимает некоторое время на старте модуля.
//  205     // чтобы не передавать в прибор недостоверную информацию подождём несколько
//  206     // циклов и вместо непроверенных данных будем сообщать о том, что они не готовы.
//  207     // мы считаем, что данные не достоверны?
//  208     if (CMvsn21::m_uiStartSkippedCyclesNumber < 13)
        LDS     R16, (??m_axMeasurementChannelRemap + 48)
        CPI     R16, 13
        LDI     R16, 0
        ST      X, R16
        BRCC    ??ReadData_1
//  209     {
//  210         // данные ещё не достоверны.
//  211         // Первый байт - пустой(эхо - заполняется в прерывании, SPDR = SPDR).
//  212         puiResponse[uiLength++] = 0;
//  213 //        // сообщим об этом кодом - COMMAND_DATA_NOT_READY
//  214 //        puiResponse[uiLength++] = COMMAND_DATA_NOT_READY;
//  215         // как контрольная сумма(хотя, протоколом не предусмотрено)
//  216         puiResponse[uiLength++] = (COMMAND_DATA_NOT_READY);
        MOVW    R31:R30, R19:R18
        LDI     R16, 36
        STD     Z+1, R16
//  217 
//  218         CMvsn21::m_uiStartSkippedCyclesNumber++;
//  219 
//  220         if (CMvsn21::m_uiStartSkippedCyclesNumber >= 13)
        LDI     R30, LOW(??m_axMeasurementChannelRemap)
        LDI     R31, (??m_axMeasurementChannelRemap) >> 8
        LDD     R16, Z+48
        INC     R16
        STD     Z+48, R16
        CPI     R16, 13
        BRCS    ??ReadData_2
//  221         {
//  222             CSpi::m_uiErrorCode = 0;
        LDI     R16, 0
        STS     ??m_uiErrorCode, R16
//  223         }
//  224 
//  225         return uiLength;
??ReadData_2:
        LDI     R16, 2
        LDI     R17, 0
        RJMP    ??ReadData_3
//  226     }
//  227     else
//  228     {
//  229         // Протокол обмена данными по шине Spi.
//  230         // Первый байт - пустой(эхо - заполняется в прерывании, SPDR = SPDR).
//  231         puiResponse[uiLength++] = 0;
??ReadData_1:
        LDI     R24, 1
        LDI     R25, 0
//  232     }
//  233 
//  234     // Следующие шесть байт - данные состояния дискретных входов.
//  235     // Упакуем двухбитовые данные состояния измерительных каналов всех чипов в дискретные входы.
//  236     // i - индекс дискретных входов.
//  237     for (int8_t i = 0; i < DISCRETE_INPUT_NUMBER; )
//  238     {
//  239         uint8_t uiState = 0;
??ReadData_4:
        LDI     R22, 0
//  240         // Упакуем двухбитовые данные состояния четырёх измерительных каналов в байт по четыре дискретных входа.
//  241         for (int8_t j= 0;
        LDI     R23, 4
//  242                 j < CHANNELS_IN_BYTE;
//  243                 j += 1)
//  244         {
//  245             // Следующие два бита в байте.
//  246             // Упаковали все данные состояния измерительных каналов?
//  247             if (i < DISCRETE_INPUT_NUMBER)
//  248             {
//  249                 // Выберем канал по индексу чипа, карты сопоставления измерительных каналов со входами модуля.
//  250                 uint8_t uiInputIndex = ((m_axMeasurementChannelRemap[i].uiChip *
//  251                                          (MEASURE_CHANNEL_NUMBER * MEASURE_CHANNEL_STATE_BIT_NUMBER)) +
//  252                                         // Выберем канал по индексу входа модуля, карты сопоставления измерительных каналов со входами модуля.
//  253                                         (m_axMeasurementChannelRemap[i].uiChannel * MEASURE_CHANNEL_STATE_BIT_NUMBER));
??ReadData_5:
        MOV     R18, R16
        MOV     R19, R16
        LSL     R19
        SBC     R19, R19
        LSL     R18
        ROL     R19
        LDI     R30, LOW(??m_axMeasurementChannelRemap)
        LDI     R31, (??m_axMeasurementChannelRemap) >> 8
        ADD     R30, R18
        ADC     R31, R19
        LD      R19, Z
        SWAP    R19
        ANDI    R19, 0xF0
        LDD     R17, Z+1
        LSL     R17
        ADD     R19, R17
//  254 
//  255                 for (int8_t k = 0;
        LDI     R18, 0
        LDI     R17, 2
//  256                         k < MEASURE_CHANNEL_STATE_BIT_NUMBER;
//  257                         k++)
//  258                 {
//  259                     uiState >>= 1;
??ReadData_6:
        LSR     R22
//  260                     // Массив с состояниями измерительных каналов чипов.
//  261                     // Состояние измерительного канала занимает два бита.
//  262                     if (m_aucRtuDiscreteInputsArray[uiInputIndex + k])
        MOV     R0, R19
        CLR     R1
        MOV     R21, R18
        LSL     R21
        SBC     R21, R21
        ADD     R0, R18
        ADC     R1, R21
        MOVW    R31:R30, R1:R0
        SUBI    R30, LOW((-(??m_aucRtuDiscreteInputsArray) & 0xFFFF))
        SBCI    R31, (-(??m_aucRtuDiscreteInputsArray) & 0xFFFF) >> 8
        LD      R20, Z
        TST     R20
        BREQ    ??ReadData_7
//  263                     {
//  264                         uiState |= 0x80;
        ORI     R22, 0x80
//  265                     }
//  266                 }
??ReadData_7:
        INC     R18
        DEC     R17
        BRNE    ??ReadData_6
//  267                 // Следующий дискретный вход.
//  268                 i++;
        INC     R16
//  269             }
        DEC     R23
        BREQ    ??ReadData_8
        CPI     R16, 24
        BRGE    ??ReadData_9
        RJMP    ??ReadData_5
//  270             else
//  271             {
//  272                 // Упаковали все данные состояния измерительных каналов.
//  273                 goto EndStateDataPack;
//  274             }
//  275         }
//  276         puiResponse[uiLength] = uiState;
??ReadData_8:
        MOVW    R31:R30, R27:R26
        ADD     R30, R24
        ADC     R31, R25
        ST      Z, R22
//  277         // Следующий байт.
//  278         uiLength++;
        ADIW    R25:R24, 1
//  279     }
        CPI     R16, 24
        BRLT    ??ReadData_4
//  280 
//  281 EndStateDataPack:
//  282 
//  283     // Последний байт - сумма всех байт начиная с третьего(пустой байт и "эхо" не учитываются).
//  284     puiResponse[uiLength] =
//  285         (usCrcSummOneByteCalculation(&puiResponse[0], (uiLength)) +
//  286          // Код запроса.
//  287          puiRequest[0]);
??ReadData_9:
        MOVW    R19:R18, R25:R24
        MOVW    R17:R16, R27:R26
        RCALL   ??usCrcSummOneByteCalculation
        MOVW    R31:R30, R5:R4
        LD      R17, Z
        ADD     R16, R17
        ADD     R26, R24
        ADC     R27, R25
        ST      X, R16
//  288 
//  289     return uiLength;
        MOVW    R17:R16, R25:R24
??ReadData_3:
        LDI     R30, 6
        RJMP    ?EPILOGUE_B6_L09
//  290 }
//  291 
//  292 //-----------------------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  293 int16_t CMvsn21::SpiReply(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiFrameLength)
??SpiReply:
//  294 {
//  295     uint16_t uiLength = uiFrameLength;
//  296     // Какой поступил запрос?
//  297     switch (puiRequest[0])
        MOVW    R31:R30, R17:R16
        LD      R22, Z
        SUBI    R22, 145
        BREQ    ??SpiReply_1
        SUBI    R22, 177
        BREQ    ??SpiReply_2
        RJMP    ??SpiReply_3
//  298     {
//  299     case COMMAND_REPORT_TYPE:
//  300         uiLength = ReportType(puiRequest, puiResponse, uiLength);
??SpiReply_1:
        RCALL   ??ReportType
        RJMP    ??SpiReply_4
//  301         break;
//  302 
//  303     case COMMAND_READ_DATA:
//  304         uiLength = ReadData(puiRequest, puiResponse, uiLength);
??SpiReply_2:
        RCALL   ??ReadData
??SpiReply_4:
        MOVW    R21:R20, R17:R16
//  305         break;
//  306 
//  307 //    case COMMAND_READ_DATA_BASE:
//  308 ////        uiLength = ReadHoldingRegisters(puiRequest, puiResponse, uiLength);
//  309 //        break;
//  310 //
//  311 //    case COMMAND_WRITE_DATA_BASE:
//  312 ////        uiLength = ReadInputRegisters(puiRequest, puiResponse, uiLength);
//  313 //        break;
//  314 
//  315     default:
//  316         break;
//  317     }
//  318     return uiLength;
??SpiReply_3:
        MOVW    R17:R16, R21:R20
        RET
//  319 }
//  320 
//  321 //-----------------------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  322 void CMvsn21::SpiFsm(void)
??SpiFsm:
//  323 {
        RCALL   ?PROLOGUE4_L09
//  324     int16_t iReceivedCounter;
//  325 
//  326     switch (m_uiFlowControl)
        LDI     R26, LOW(??m_uiMessageLength)
        LDI     R27, (??m_uiMessageLength) >> 8
        LDS     R16, (??m_uiMessageLength + 2)
        DEC     R16
        BREQ    ??SpiFsm_1
        DEC     R16
        BREQ    ??SpiFsm_2
        SUBI    R16, 8
        BREQ    ??SpiFsm_3
        RJMP    ??SpiFsm_4
//  327     {
//  328     case FSM_IDDLE:
//  329         break;
//  330 
//  331     case FSM_START:
//  332 //        Reset();
//  333         CSpi::Reset();
??SpiFsm_1:
        RCALL   ??Reset
//  334         m_uiMessageLength = 0;
        LDI     R16, 0
        ST      X+, R16
        ST      X, R16
//  335         m_uiFlowControl = FSM_WAITING_MESSAGE;
        LDI     R16, 2
??SpiFsm_5:
        STS     (??m_uiMessageLength + 2), R16
//  336         break;
//  337 
//  338     case FSM_WAITING_MESSAGE:
//  339         if (CSpi::ByteIsReceived())
//  340 //        if (Select())
//  341         {
//  342 //            iReceivedCounter = Exchange();
//  343             iReceivedCounter = CSpi::Exchange();
//  344 
//  345             if (iReceivedCounter > 0)
//  346             {
//  347                 m_uiMessageLength += iReceivedCounter;
//  348 
//  349                 if (SpiReply(CSpi::m_puiRxBuffer, CSpi::m_puiTxBuffer, m_uiMessageLength))
//  350                 {
//  351                     m_uiFlowControl = FSM_DATA_EXCHANGE_END_WAITING;
//  352                 }
//  353                 else
//  354                 {
//  355                     m_uiFlowControl = FSM_IDDLE;
//  356                 }
//  357             }
//  358             else if (iReceivedCounter == -1)
//  359             {
//  360                 m_uiFlowControl = FSM_IDDLE;
//  361             }
//  362         }
//  363 
//  364         break;
//  365 
//  366     case FSM_DATA_EXCHANGE_END_WAITING:
//  367         break;
//  368 
//  369     case FSM_DATA_EXCHANGE_END:
//  370         if (CModbus::m_uiSlaveAddress >= 2)
//  371         {
//  372             CModbus::m_uiSlaveAddress = 1;
//  373         }
//  374         else
//  375         {
//  376             CModbus::m_uiSlaveAddress += 1;
//  377         }
//  378         CModbus::ReadDiscreteInputsRequest((CModbus::m_uiSlaveAddress),
//  379                                            0,
//  380                                            (MEASURE_CHANNEL_NUMBER * MEASURE_CHANNEL_STATE_BIT_NUMBER));
//  381         m_uiFlowControl = FSM_IDDLE;
//  382         break;
//  383 
//  384     default:
//  385         break;
//  386     }
//  387 
//  388 }
??SpiFsm_4:
        RJMP    ?Subroutine1
??SpiFsm_2:
        LDS     R16, ??m_bfByteIsReceived
        TST     R16
        BREQ    ??SpiFsm_4
        RCALL   ??Exchange
        CPI     R16, 1
        LDI     R18, 0
        CPC     R17, R18
        BRLT    ??SpiFsm_6
        LD      R18, X+
        LD      R19, X
        ADD     R18, R16
        ADC     R19, R17
        ST      X, R19
        ST      -X, R18
        MOVW    R21:R20, R19:R18
        LDI     R30, LOW(??m_puiTxBuffer)
        LDI     R31, (??m_puiTxBuffer) >> 8
        LD      R18, Z
        LDD     R19, Z+1
        LDI     R30, LOW(??m_puiRxBuffer)
        LDI     R31, (??m_puiRxBuffer) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        RCALL   ??SpiReply
        OR      R16, R17
        BREQ    ??SpiFsm_7
        LDI     R16, 9
        RJMP    ??SpiFsm_5
??SpiFsm_6:
        CPI     R16, 255
        SBCI    R17, 255
        BRNE    ??SpiFsm_4
??SpiFsm_7:
        LDI     R16, 0
        RJMP    ??SpiFsm_5
??SpiFsm_3:
        LDS     R16, ??m_uiSlaveAddress
        CPI     R16, 2
        BRCS    ??SpiFsm_8
        LDI     R16, 1
        RJMP    ??SpiFsm_9
??SpiFsm_8:
        INC     R16
??SpiFsm_9:
        STS     ??m_uiSlaveAddress, R16
        LDI     R20, 16
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        RCALL   ??ReadDiscreteInputsRequest
        RJMP    ??SpiFsm_7
//  389 
//  390 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  391 void CMvsn21::MeasureFsm(void)
??MeasureFsm:
//  392 {
        RCALL   ?PROLOGUE4_L09
        LDS     R16, (??m_axSameStateCheck + 17)
        TST     R16
        BREQ    ??MeasureFsm_1
        DEC     R16
        BREQ    ??MeasureFsm_2
        SUBI    R16, 10
        BREQ    ??MeasureFsm_3
        RJMP    ??MeasureFsm_4
//  393     switch (m_uiMeasureFlowControl)
//  394     {
//  395     case FSM_IDDLE:
//  396         CPlatform::WatchdogReset();
??MeasureFsm_1:
        WDR
//  397         break;
        RJMP    ??MeasureFsm_4
//  398 
//  399     case FSM_START:
//  400         m_uiChannel = 0;
??MeasureFsm_2:
        LDI     R16, 0
        STS     (??m_axSameStateCheck + 16), R16
//  401         CAdc::Enable();
        RCALL   ??Enable
//  402         CAdc::ChannelSelect(m_uiChannel);
        RCALL   ?Subroutine0
//  403         CAdc::Start();
//  404         m_uiMeasureFlowControl = FSM_CONTINUOUS_MEASURE;
??CrossCallReturnLabel_1:
        LDI     R16, 11
        RJMP    ??MeasureFsm_5
//  405         break;
//  406 
//  407     case FSM_CONTINUOUS_MEASURE:
//  408         if (CAdc::MeasureIsComlete())
??MeasureFsm_3:
        LDS     R16, _A_ADCSRA
        SBRS    R16, 4
        RJMP    ??MeasureFsm_4
        LDS     R16, 122
        ORI     R16, 0x10
        STS     122, R16
//  409         {
//  410             uint8_t uiState =
//  411                 CMeasurementChannel::StateCheck(CAdc::GetMeasureValue());
        RCALL   ??GetMeasureValue
        RCALL   ??StateCheck
//  412 
//  413             // Предыдущее состояние дискретного входа совпадает с текущим?
//  414             if (m_axSameStateCheck[m_uiChannel].uiState == uiState)
        LDS     R17, (??m_axSameStateCheck + 16)
        LDI     R18, 2
        MUL     R17, R18
        LDI     R30, LOW(??m_axSameStateCheck)
        LDI     R31, (??m_axSameStateCheck) >> 8
        ADD     R30, R0
        ADC     R31, R1
        LD      R17, Z
        CP      R17, R16
        BRNE    ??MeasureFsm_6
//  415             {
//  416                 // Cостояние дискретного входа изменилось не в результате помехи?
//  417                 if (m_axSameStateCheck[m_uiChannel].uiSameStateCounter >= SAME_STATE_CHECK_NUMBER)
        LDD     R16, Z+1
        CPI     R16, 3
        BRCS    ??MeasureFsm_7
//  418                 {
//  419                     m_aucRtuDiscreteInputsArray[(m_uiChannel * 2) + (MEASURE_CHANNEL_NUMBER * MEASURE_CHANNEL_STATE_BIT_NUMBER * 2)] = (m_axSameStateCheck[m_uiChannel].uiState & 0x01);
        LDI     R26, LOW(??m_aucRtuDiscreteInputsArray)
        LDI     R27, (??m_aucRtuDiscreteInputsArray) >> 8
        ADD     R26, R0
        ADC     R27, R1
        ANDI    R17, 0x01
        ADIW    R27:R26, 32
        ST      X, R17
        ADIW    R27:R26, 1
//  420                     m_aucRtuDiscreteInputsArray[(m_uiChannel * 2) + (MEASURE_CHANNEL_NUMBER * MEASURE_CHANNEL_STATE_BIT_NUMBER * 2) + 1] = ((m_axSameStateCheck[m_uiChannel].uiState >> 1) & 0x01);
        LD      R16, Z
        BST     R16, 1
        LDI     R16, 0
        BLD     R16, 0
        ST      X, R16
        RJMP    ??MeasureFsm_8
//  421                 }
//  422                 else
//  423                 {
//  424                     m_axSameStateCheck[m_uiChannel].uiSameStateCounter += 1;
??MeasureFsm_7:
        INC     R16
        RJMP    ??MeasureFsm_9
//  425                 }
//  426             }
//  427             else
//  428             {
//  429                 // Предыдущее состояние дискретного входа не совпадает с текущим.
//  430                 // Сохраним новое состояние.
//  431                 m_axSameStateCheck[m_uiChannel].uiState = uiState;
??MeasureFsm_6:
        ST      Z, R16
//  432                 m_axSameStateCheck[m_uiChannel].uiSameStateCounter = 0;
        LDI     R16, 0
??MeasureFsm_9:
        STD     Z+1, R16
//  433             }
//  434 
//  435             m_uiChannel++;
??MeasureFsm_8:
        LDI     R30, LOW(??m_axSameStateCheck)
        LDI     R31, (??m_axSameStateCheck) >> 8
        LDD     R16, Z+16
        INC     R16
        STD     Z+16, R16
//  436             if (m_uiChannel < MEASURE_CHANNEL_NUMBER)
        CPI     R16, 8
        BRCC    ??MeasureFsm_10
//  437             {
//  438                 CAdc::Stop();
        RCALL   ??Stop
//  439                 CAdc::ChannelSelect(m_uiChannel);
        RCALL   ?Subroutine0
//  440                 CAdc::Start();
//  441             }
??CrossCallReturnLabel_0:
        RJMP    ??MeasureFsm_4
//  442             else
//  443             {
//  444                 CAdc::Disable();
??MeasureFsm_10:
        RCALL   ??Disable
//  445                 m_uiMeasureFlowControl = FSM_IDDLE;
        LDI     R16, 0
??MeasureFsm_5:
        STS     (??m_axSameStateCheck + 17), R16
//  446             }
//  447         }
//  448         break;
//  449 
//  450     default:
//  451         break;
//  452     }
//  453 }
??MeasureFsm_4:
        REQUIRE ?Subroutine1
        REQUIRE _A_ADCSRA
        ;               // Fall through to label ?Subroutine1

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
        LDS     R16, (??m_axSameStateCheck + 16)
        RCALL   ??ChannelSelect
        RJMP    ??Start

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        RSEG NEAR_ID:CODE:ROOT(0)
`?<Initializer for m_axMeasurementChannelRemap>`:
        DC8 0, 6, 0, 7, 0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 1, 6, 1, 7, 1, 0, 1
        DC8 1, 1, 2, 1, 3, 1, 4, 1, 5, 2, 6, 2, 7, 2, 0, 2, 1, 2, 2, 2, 3, 2, 4
        DC8 2, 5
`?<Initializer for m_uiStartSkippedCyclesNumber`:
        DC8 0

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_I>`:
        DC16    SFE(NEAR_I) - SFB(NEAR_I)
        DC16    SFB(NEAR_I)
        DC16    SFB(NEAR_ID)
        REQUIRE ?need_segment_init

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0

        END
//  454 
//  455 
//  456 
//  457 
//  458 
//  459 
//  460 
//  461 ////-----------------------------------------------------------------------------------------------------
//  462 //CMvsn21Driver::CMvsn21Driver(uint8_t uiType) :
//  463 //
//  464 //    m_uiType(uiType),
//  465 //{
//  466 //
//  467 //}
//  468 //
//  469 ////-----------------------------------------------------------------------------------------------------
//  470 //CMvsn21Driver::~CMvsn21Driver()
//  471 //{
//  472 //
//  473 //}
//  474 //
//  475 ////-----------------------------------------------------------------------------------------------------
//  476 //uint16_t CMvsn21Driver::TypeReport(uint8_t *puiDestination, uint16_t uiLength)
//  477 //{
//  478 //
//  479 //}
// 
//  87 bytes in segment ABSOLUTE
// 540 bytes in segment CODE
//  12 bytes in segment INITTAB
//   2 bytes in segment NEAR_F
//  49 bytes in segment NEAR_I
//  49 bytes in segment NEAR_ID
// 134 bytes in segment NEAR_Z
// 
// 591 bytes of CODE memory (+ 12 bytes shared)
// 183 bytes of DATA memory (+ 87 bytes shared)
//
//Errors: none
//Warnings: 5
